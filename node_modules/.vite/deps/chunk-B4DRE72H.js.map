{
  "version": 3,
  "sources": ["../../ol/interaction/Draw.js"],
  "sourcesContent": ["/**\r\n * @module ol/interaction/Draw\r\n */\r\nimport Circle from '../geom/Circle.js';\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport Feature from '../Feature.js';\r\nimport GeometryCollection from '../geom/GeometryCollection.js';\r\nimport InteractionProperty from './Property.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport MapBrowserEvent from '../MapBrowserEvent.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport MultiLineString from '../geom/MultiLineString.js';\r\nimport MultiPoint from '../geom/MultiPoint.js';\r\nimport MultiPolygon from '../geom/MultiPolygon.js';\r\nimport Point from '../geom/Point.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {FALSE, TRUE} from '../functions.js';\r\nimport {\r\n  always,\r\n  never,\r\n  noModifierKeys,\r\n  shiftKeyOnly,\r\n} from '../events/condition.js';\r\nimport {\r\n  boundingExtent,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n} from '../extent.js';\r\nimport {clamp, squaredDistance, toFixed} from '../math.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {\r\n  distance,\r\n  squaredDistance as squaredCoordinateDistance,\r\n} from '../coordinate.js';\r\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\r\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\r\n * the geometries being drawn with this instance.\r\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\r\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\r\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\r\n * was chosen for the draw interaction to behave correctly on mouse as well as\r\n * on touch devices.\r\n * @property {import(\"../Collection.js\").default<Feature>} [features]\r\n * Destination collection for the drawn features.\r\n * @property {VectorSource} [source] Destination source for\r\n * the drawn features.\r\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\r\n * before the current vertex can be dragged to its exact position.\r\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\r\n * drawing finish. Must be greater than `0`.\r\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\r\n * doubleclick events from firing during drawing.\r\n * @property {number} [maxPoints] The number of points that can be drawn before\r\n * a polygon ring or line string is finished. By default there is no\r\n * restriction.\r\n * @property {number} [minPoints] The number of points that must be drawn\r\n * before a polygon ring or line string can be finished. Default is `3` for\r\n * polygon rings and `2` for line strings.\r\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\r\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether the drawing can be finished. Not used when drawing\r\n * POINT or MULTI_POINT geometries.\r\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\r\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\r\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\r\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\r\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\r\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\r\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\r\n * (note that this polygon has only two points if only one point is drawn).\r\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\r\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\r\n * @property {GeometryFunction} [geometryFunction]\r\n * Function that is called when a geometry's coordinates are updated.\r\n * @property {string} [geometryName] Geometry name to use for features created\r\n * by the draw interaction.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\r\n * adds a vertex or deactivates freehand drawing.\r\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\r\n * polygons, and circles.  This makes the interaction always operate in freehand\r\n * mode and takes precedence over any `freehandCondition` option.\r\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\r\n * Condition that activates freehand drawing for lines and polygons. This\r\n * function takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\r\n * returns a boolean to indicate whether that event should be handled. The\r\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\r\n * Shift key activates freehand drawing.\r\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\r\n * Ignored when in freehand mode.\r\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\r\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\r\n * either a `traceSource` or a `source`.\r\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\r\n * overlay.\r\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\r\n * feature geometries created by the draw interaction.\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing points.\r\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing lines.\r\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\r\n */\r\n\r\n/**\r\n * Coordinate type when drawing polygons.\r\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\r\n */\r\n\r\n/**\r\n * Types used for drawing coordinates.\r\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\r\n */\r\n\r\n/**\r\n * @typedef {Object} TraceState\r\n * @property {boolean} active Tracing active.\r\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\r\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\r\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\r\n * that no trace target is active.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TraceTarget\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\r\n * @property {boolean} ring The target coordinates are a linear ring.\r\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\r\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\r\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\r\n */\r\n\r\n/**\r\n * Function that takes an array of coordinates and an optional existing geometry\r\n * and a projection as arguments, and returns a geometry. The optional existing\r\n * geometry is the geometry that is returned when the function is called without\r\n * a second argument.\r\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\r\n *     import(\"../proj/Projection.js\").default):\r\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\r\n */\r\n\r\n/**\r\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\r\n * Draw mode.  This collapses multi-part geometry types with their single-part\r\n * cousins.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst DrawEventType = {\r\n  /**\r\n   * Triggered upon feature draw start\r\n   * @event DrawEvent#drawstart\r\n   * @api\r\n   */\r\n  DRAWSTART: 'drawstart',\r\n  /**\r\n   * Triggered upon feature draw end\r\n   * @event DrawEvent#drawend\r\n   * @api\r\n   */\r\n  DRAWEND: 'drawend',\r\n  /**\r\n   * Triggered upon feature draw abortion\r\n   * @event DrawEvent#drawabort\r\n   * @api\r\n   */\r\n  DRAWABORT: 'drawabort',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\r\n * instances of this type.\r\n */\r\nexport class DrawEvent extends Event {\r\n  /**\r\n   * @param {DrawEventType} type Type.\r\n   * @param {Feature} feature The feature drawn.\r\n   */\r\n  constructor(type, feature) {\r\n    super(type);\r\n\r\n    /**\r\n     * The feature being drawn.\r\n     * @type {Feature}\r\n     * @api\r\n     */\r\n    this.feature = feature;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {Array<Feature>} features The candidate features.\r\n * @return {Array<TraceTarget>} The trace targets.\r\n */\r\nfunction getTraceTargets(coordinate, features) {\r\n  /**\r\n   * @type {Array<TraceTarget>}\r\n   */\r\n  const targets = [];\r\n\r\n  for (let i = 0; i < features.length; ++i) {\r\n    const feature = features[i];\r\n    const geometry = feature.getGeometry();\r\n    appendGeometryTraceTargets(coordinate, geometry, targets);\r\n  }\r\n\r\n  return targets;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\r\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\r\n * @return {number} The squared distance between the two coordinates.\r\n */\r\nfunction getSquaredDistance(a, b) {\r\n  return squaredDistance(a[0], a[1], b[0], b[1]);\r\n}\r\n\r\n/**\r\n * @param {LineCoordType} coordinates The ring coordinates.\r\n * @param {number} index The index.  May be wrapped.\r\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\r\n */\r\nfunction getCoordinate(coordinates, index) {\r\n  const count = coordinates.length;\r\n  if (index < 0) {\r\n    return coordinates[index + count];\r\n  }\r\n  if (index >= count) {\r\n    return coordinates[index - count];\r\n  }\r\n  return coordinates[index];\r\n}\r\n\r\n/**\r\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\r\n * be less than the start index to indicate the direction of travel.  The start and end index may have\r\n * a fractional part to indicate a point between two coordinates.\r\n * @param {LineCoordType} coordinates Ring coordinates.\r\n * @param {number} startIndex The start index.\r\n * @param {number} endIndex The end index.\r\n * @return {number} The cumulative squared distance along the ring path.\r\n */\r\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\r\n  let lowIndex, highIndex;\r\n  if (startIndex < endIndex) {\r\n    lowIndex = startIndex;\r\n    highIndex = endIndex;\r\n  } else {\r\n    lowIndex = endIndex;\r\n    highIndex = startIndex;\r\n  }\r\n  const lowWholeIndex = Math.ceil(lowIndex);\r\n  const highWholeIndex = Math.floor(highIndex);\r\n\r\n  if (lowWholeIndex > highWholeIndex) {\r\n    // both start and end are on the same segment\r\n    const start = interpolateCoordinate(coordinates, lowIndex);\r\n    const end = interpolateCoordinate(coordinates, highIndex);\r\n    return getSquaredDistance(start, end);\r\n  }\r\n\r\n  let sd = 0;\r\n\r\n  if (lowIndex < lowWholeIndex) {\r\n    const start = interpolateCoordinate(coordinates, lowIndex);\r\n    const end = getCoordinate(coordinates, lowWholeIndex);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  if (highWholeIndex < highIndex) {\r\n    const start = getCoordinate(coordinates, highWholeIndex);\r\n    const end = interpolateCoordinate(coordinates, highIndex);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\r\n    const start = getCoordinate(coordinates, i);\r\n    const end = getCoordinate(coordinates, i + 1);\r\n    sd += getSquaredDistance(start, end);\r\n  }\r\n\r\n  return sd;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\r\n * @param {Array<TraceTarget>} targets The trace targets.\r\n */\r\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\r\n  if (geometry instanceof LineString) {\r\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\r\n    return;\r\n  }\r\n  if (geometry instanceof MultiLineString) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof Polygon) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof MultiPolygon) {\r\n    const polys = geometry.getCoordinates();\r\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\r\n      const coordinates = polys[i];\r\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\r\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n  if (geometry instanceof GeometryCollection) {\r\n    const geometries = geometry.getGeometries();\r\n    for (let i = 0; i < geometries.length; ++i) {\r\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\r\n    }\r\n    return;\r\n  }\r\n  // other types cannot be traced\r\n}\r\n\r\n/**\r\n * @typedef {Object} TraceTargetUpdateInfo\r\n * @property {number} index The new target index.\r\n * @property {number} endIndex The new segment end index.\r\n */\r\n\r\n/**\r\n * @type {TraceTargetUpdateInfo}\r\n */\r\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @param {TraceState} traceState The trace state.\r\n * @param {import(\"../Map.js\").default} map The map.\r\n * @param {number} snapTolerance The snap tolerance.\r\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\r\n * object is reused between calls and must not be modified by the caller.\r\n */\r\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n\r\n  let closestTargetDistance = Infinity;\r\n\r\n  let newTargetIndex = -1;\r\n  let newEndIndex = NaN;\r\n\r\n  for (\r\n    let targetIndex = 0;\r\n    targetIndex < traceState.targets.length;\r\n    ++targetIndex\r\n  ) {\r\n    const target = traceState.targets[targetIndex];\r\n    const coordinates = target.coordinates;\r\n\r\n    let minSegmentDistance = Infinity;\r\n    let endIndex;\r\n    for (\r\n      let coordinateIndex = 0;\r\n      coordinateIndex < coordinates.length - 1;\r\n      ++coordinateIndex\r\n    ) {\r\n      const start = coordinates[coordinateIndex];\r\n      const end = coordinates[coordinateIndex + 1];\r\n      const rel = getPointSegmentRelationship(x, y, start, end);\r\n      if (rel.squaredDistance < minSegmentDistance) {\r\n        minSegmentDistance = rel.squaredDistance;\r\n        endIndex = coordinateIndex + rel.along;\r\n      }\r\n    }\r\n\r\n    if (minSegmentDistance < closestTargetDistance) {\r\n      closestTargetDistance = minSegmentDistance;\r\n      if (target.ring && traceState.targetIndex === targetIndex) {\r\n        // same target, maintain the same trace direction\r\n        if (target.endIndex > target.startIndex) {\r\n          // forward trace\r\n          if (endIndex < target.startIndex) {\r\n            endIndex += coordinates.length;\r\n          }\r\n        } else if (target.endIndex < target.startIndex) {\r\n          // reverse trace\r\n          if (endIndex > target.startIndex) {\r\n            endIndex -= coordinates.length;\r\n          }\r\n        }\r\n      }\r\n      newEndIndex = endIndex;\r\n      newTargetIndex = targetIndex;\r\n    }\r\n  }\r\n\r\n  const newTarget = traceState.targets[newTargetIndex];\r\n  let considerBothDirections = newTarget.ring;\r\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\r\n    // only consider switching trace direction if close to the start\r\n    const newCoordinate = interpolateCoordinate(\r\n      newTarget.coordinates,\r\n      newEndIndex,\r\n    );\r\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\r\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\r\n      considerBothDirections = false;\r\n    }\r\n  }\r\n\r\n  if (considerBothDirections) {\r\n    const coordinates = newTarget.coordinates;\r\n    const count = coordinates.length;\r\n    const startIndex = newTarget.startIndex;\r\n    const endIndex = newEndIndex;\r\n    if (startIndex < endIndex) {\r\n      const forwardDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex,\r\n      );\r\n      const reverseDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex - count,\r\n      );\r\n      if (reverseDistance < forwardDistance) {\r\n        newEndIndex -= count;\r\n      }\r\n    } else {\r\n      const reverseDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex,\r\n      );\r\n      const forwardDistance = getCumulativeSquaredDistance(\r\n        coordinates,\r\n        startIndex,\r\n        endIndex + count,\r\n      );\r\n      if (forwardDistance < reverseDistance) {\r\n        newEndIndex += count;\r\n      }\r\n    }\r\n  }\r\n\r\n  sharedUpdateInfo.index = newTargetIndex;\r\n  sharedUpdateInfo.endIndex = newEndIndex;\r\n  return sharedUpdateInfo;\r\n}\r\n\r\n/**\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\r\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\r\n * @param {boolean} ring The coordinates represent a linear ring.\r\n * @param {Array<TraceTarget>} targets The trace targets.\r\n */\r\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n    const start = coordinates[i];\r\n    const end = coordinates[i + 1];\r\n    const rel = getPointSegmentRelationship(x, y, start, end);\r\n    if (rel.squaredDistance === 0) {\r\n      const index = i + rel.along;\r\n      targets.push({\r\n        coordinates: coordinates,\r\n        ring: ring,\r\n        startIndex: index,\r\n        endIndex: index,\r\n      });\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} PointSegmentRelationship\r\n * @property {number} along The closest point expressed as a fraction along the segment length.\r\n * @property {number} squaredDistance The squared distance of the point to the segment.\r\n */\r\n\r\n/**\r\n * @type {PointSegmentRelationship}\r\n */\r\nconst sharedRel = {along: 0, squaredDistance: 0};\r\n\r\n/**\r\n * @param {number} x The point x.\r\n * @param {number} y The point y.\r\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\r\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\r\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\r\n * shared between calls and must not be modified by the caller.\r\n */\r\nfunction getPointSegmentRelationship(x, y, start, end) {\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  let along = 0;\r\n  let px = x1;\r\n  let py = y1;\r\n  if (dx !== 0 || dy !== 0) {\r\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\r\n    px += dx * along;\r\n    py += dy * along;\r\n  }\r\n\r\n  sharedRel.along = along;\r\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\r\n  return sharedRel;\r\n}\r\n\r\n/**\r\n * @param {LineCoordType} coordinates The coordinates.\r\n * @param {number} index The index.  May be fractional and may wrap.\r\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\r\n */\r\nfunction interpolateCoordinate(coordinates, index) {\r\n  const count = coordinates.length;\r\n\r\n  let startIndex = Math.floor(index);\r\n  const along = index - startIndex;\r\n  if (startIndex >= count) {\r\n    startIndex -= count;\r\n  } else if (startIndex < 0) {\r\n    startIndex += count;\r\n  }\r\n\r\n  let endIndex = startIndex + 1;\r\n  if (endIndex >= count) {\r\n    endIndex -= count;\r\n  }\r\n\r\n  const start = coordinates[startIndex];\r\n  const x0 = start[0];\r\n  const y0 = start[1];\r\n  const end = coordinates[endIndex];\r\n  const dx = end[0] - x0;\r\n  const dy = end[1] - y0;\r\n\r\n  return [x0 + dx * along, y0 + dy * along];\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for drawing feature geometries.\r\n *\r\n * @fires DrawEvent\r\n * @api\r\n */\r\nclass Draw extends PointerInteraction {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\r\n      options\r\n    );\r\n    if (!pointerOptions.stopDown) {\r\n      pointerOptions.stopDown = FALSE;\r\n    }\r\n\r\n    super(pointerOptions);\r\n\r\n    /***\r\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {DrawOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.shouldHandle_ = false;\r\n\r\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     * @private\r\n     */\r\n    this.downPx_ = null;\r\n\r\n    /**\r\n     * @type {ReturnType<typeof setTimeout>}\r\n     * @private\r\n     */\r\n    this.downTimeout_;\r\n\r\n    /**\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.lastDragTime_;\r\n\r\n    /**\r\n     * Pointer type of the last pointermove event\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.pointerType_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.freehand_ = false;\r\n\r\n    /**\r\n     * Target source for drawn features.\r\n     * @type {VectorSource|null}\r\n     * @private\r\n     */\r\n    this.source_ = options.source ? options.source : null;\r\n\r\n    /**\r\n     * Target collection for drawn features.\r\n     * @type {import(\"../Collection.js\").default<Feature>|null}\r\n     * @private\r\n     */\r\n    this.features_ = options.features ? options.features : null;\r\n\r\n    /**\r\n     * Pixel distance for snapping.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\r\n\r\n    /**\r\n     * Geometry type.\r\n     * @type {import(\"../geom/Geometry.js\").Type}\r\n     * @private\r\n     */\r\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\r\n      options.type\r\n    );\r\n\r\n    /**\r\n     * Drawing mode (derived from geometry type.\r\n     * @type {Mode}\r\n     * @private\r\n     */\r\n    this.mode_ = getMode(this.type_);\r\n\r\n    /**\r\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\r\n     * Default is `false`.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.stopClick_ = !!options.stopClick;\r\n\r\n    /**\r\n     * The number of points that must be drawn before a polygon ring or line\r\n     * string can be finished.  The default is 3 for polygon rings and 2 for\r\n     * line strings.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minPoints_ = options.minPoints\r\n      ? options.minPoints\r\n      : this.mode_ === 'Polygon'\r\n        ? 3\r\n        : 2;\r\n\r\n    /**\r\n     * The number of points that can be drawn before a polygon ring or line string\r\n     * is finished. The default is no restriction.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxPoints_ =\r\n      this.mode_ === 'Circle'\r\n        ? 2\r\n        : options.maxPoints\r\n          ? options.maxPoints\r\n          : Infinity;\r\n\r\n    /**\r\n     * A function to decide if a potential finish coordinate is permissible\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.finishCondition_ = options.finishCondition\r\n      ? options.finishCondition\r\n      : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\r\n     */\r\n    this.geometryLayout_ = options.geometryLayout\r\n      ? options.geometryLayout\r\n      : 'XY';\r\n\r\n    let geometryFunction = options.geometryFunction;\r\n    if (!geometryFunction) {\r\n      const mode = this.mode_;\r\n      if (mode === 'Circle') {\r\n        /**\r\n         * @param {!LineCoordType} coordinates The coordinates.\r\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\r\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\r\n         */\r\n        geometryFunction = (coordinates, geometry, projection) => {\r\n          const circle = geometry\r\n            ? /** @type {Circle} */ (geometry)\r\n            : new Circle([NaN, NaN]);\r\n          const center = fromUserCoordinate(coordinates[0], projection);\r\n          const squaredLength = squaredCoordinateDistance(\r\n            center,\r\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\r\n          );\r\n          circle.setCenterAndRadius(\r\n            center,\r\n            Math.sqrt(squaredLength),\r\n            this.geometryLayout_,\r\n          );\r\n          const userProjection = getUserProjection();\r\n          if (userProjection) {\r\n            circle.transform(projection, userProjection);\r\n          }\r\n          return circle;\r\n        };\r\n      } else {\r\n        let Constructor;\r\n        if (mode === 'Point') {\r\n          Constructor = Point;\r\n        } else if (mode === 'LineString') {\r\n          Constructor = LineString;\r\n        } else if (mode === 'Polygon') {\r\n          Constructor = Polygon;\r\n        }\r\n        /**\r\n         * @param {!LineCoordType} coordinates The coordinates.\r\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\r\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\r\n         */\r\n        geometryFunction = (coordinates, geometry, projection) => {\r\n          if (geometry) {\r\n            if (mode === 'Polygon') {\r\n              if (coordinates[0].length) {\r\n                // Add a closing coordinate to match the first\r\n                geometry.setCoordinates(\r\n                  [coordinates[0].concat([coordinates[0][0]])],\r\n                  this.geometryLayout_,\r\n                );\r\n              } else {\r\n                geometry.setCoordinates([], this.geometryLayout_);\r\n              }\r\n            } else {\r\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\r\n            }\r\n          } else {\r\n            geometry = new Constructor(coordinates, this.geometryLayout_);\r\n          }\r\n          return geometry;\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @type {GeometryFunction}\r\n     * @private\r\n     */\r\n    this.geometryFunction_ = geometryFunction;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.dragVertexDelay_ =\r\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\r\n\r\n    /**\r\n     * Finish coordinate for the feature (first point for polygons, last point for\r\n     * linestrings).\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.finishCoordinate_ = null;\r\n\r\n    /**\r\n     * Sketch feature.\r\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\r\n     * @private\r\n     */\r\n    this.sketchFeature_ = null;\r\n\r\n    /**\r\n     * Sketch point.\r\n     * @type {Feature<Point>}\r\n     * @private\r\n     */\r\n    this.sketchPoint_ = null;\r\n\r\n    /**\r\n     * Sketch coordinates. Used when drawing a line or polygon.\r\n     * @type {SketchCoordType}\r\n     * @private\r\n     */\r\n    this.sketchCoords_ = null;\r\n\r\n    /**\r\n     * Sketch line. Used when drawing polygon.\r\n     * @type {Feature<LineString>}\r\n     * @private\r\n     */\r\n    this.sketchLine_ = null;\r\n\r\n    /**\r\n     * Sketch line coordinates. Used when drawing a polygon or circle.\r\n     * @type {LineCoordType}\r\n     * @private\r\n     */\r\n    this.sketchLineCoords_ = null;\r\n\r\n    /**\r\n     * Squared tolerance for handling up events.  If the squared distance\r\n     * between a down and up event is greater than this tolerance, up events\r\n     * will not be handled.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.squaredClickTolerance_ = options.clickTolerance\r\n      ? options.clickTolerance * options.clickTolerance\r\n      : 36;\r\n\r\n    /**\r\n     * Draw overlay where our sketch features are drawn.\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.overlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: options.wrapX ? options.wrapX : false,\r\n      }),\r\n      style: options.style ? options.style : getDefaultStyleFunction(),\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    /**\r\n     * Name of the geometry attribute for newly created features.\r\n     * @type {string|undefined}\r\n     * @private\r\n     */\r\n    this.geometryName_ = options.geometryName;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.freehandCondition_;\r\n    if (options.freehand) {\r\n      this.freehandCondition_ = always;\r\n    } else {\r\n      this.freehandCondition_ = options.freehandCondition\r\n        ? options.freehandCondition\r\n        : shiftKeyOnly;\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.traceCondition_;\r\n    this.setTrace(options.trace || false);\r\n\r\n    /**\r\n     * @type {TraceState}\r\n     * @private\r\n     */\r\n    this.traceState_ = {active: false};\r\n\r\n    /**\r\n     * @type {VectorSource|null}\r\n     * @private\r\n     */\r\n    this.traceSource_ = options.traceSource || options.source || null;\r\n\r\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\r\n  }\r\n\r\n  /**\r\n   * Toggle tracing mode or set a tracing condition.\r\n   *\r\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\r\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\r\n   */\r\n  setTrace(trace) {\r\n    let condition;\r\n    if (!trace) {\r\n      condition = never;\r\n    } else if (trace === true) {\r\n      condition = always;\r\n    } else {\r\n      condition = trace;\r\n    }\r\n    this.traceCondition_ = condition;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @override\r\n   */\r\n  setMap(map) {\r\n    super.setMap(map);\r\n    this.updateState_();\r\n  }\r\n\r\n  /**\r\n   * Get the overlay layer that this interaction renders sketch features to.\r\n   * @return {VectorLayer} Overlay layer.\r\n   * @api\r\n   */\r\n  getOverlay() {\r\n    return this.overlay_;\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   * @override\r\n   */\r\n  handleEvent(event) {\r\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\r\n      // Avoid context menu for long taps when drawing on mobile\r\n      event.originalEvent.preventDefault();\r\n    }\r\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\r\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\r\n    let pass = true;\r\n    if (\r\n      !this.freehand_ &&\r\n      this.lastDragTime_ &&\r\n      event.type === MapBrowserEventType.POINTERDRAG\r\n    ) {\r\n      const now = Date.now();\r\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\r\n        this.downPx_ = event.pixel;\r\n        this.shouldHandle_ = !this.freehand_;\r\n        move = true;\r\n      } else {\r\n        this.lastDragTime_ = undefined;\r\n      }\r\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\r\n        clearTimeout(this.downTimeout_);\r\n        this.downTimeout_ = undefined;\r\n      }\r\n    }\r\n    if (\r\n      this.freehand_ &&\r\n      event.type === MapBrowserEventType.POINTERDRAG &&\r\n      this.sketchFeature_ !== null\r\n    ) {\r\n      this.addToDrawing_(event.coordinate);\r\n      pass = false;\r\n    } else if (\r\n      this.freehand_ &&\r\n      event.type === MapBrowserEventType.POINTERDOWN\r\n    ) {\r\n      pass = false;\r\n    } else if (move && this.getPointerCount() < 2) {\r\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\r\n      if (pass && this.freehand_) {\r\n        this.handlePointerMove_(event);\r\n        if (this.shouldHandle_) {\r\n          // Avoid page scrolling when freehand drawing on mobile\r\n          event.originalEvent.preventDefault();\r\n        }\r\n      } else if (\r\n        event.originalEvent.pointerType === 'mouse' ||\r\n        (event.type === MapBrowserEventType.POINTERDRAG &&\r\n          this.downTimeout_ === undefined)\r\n      ) {\r\n        this.handlePointerMove_(event);\r\n      }\r\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\r\n      pass = false;\r\n    }\r\n\r\n    return super.handleEvent(event) && pass;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\r\n  handleDownEvent(event) {\r\n    this.shouldHandle_ = !this.freehand_;\r\n\r\n    if (this.freehand_) {\r\n      this.downPx_ = event.pixel;\r\n      if (!this.finishCoordinate_) {\r\n        this.startDrawing_(event.coordinate);\r\n      }\r\n      return true;\r\n    }\r\n\r\n    if (!this.condition_(event)) {\r\n      this.lastDragTime_ = undefined;\r\n      return false;\r\n    }\r\n\r\n    this.lastDragTime_ = Date.now();\r\n    this.downTimeout_ = setTimeout(() => {\r\n      this.handlePointerMove_(\r\n        new MapBrowserEvent(\r\n          MapBrowserEventType.POINTERMOVE,\r\n          event.map,\r\n          event.originalEvent,\r\n          false,\r\n          event.frameState,\r\n        ),\r\n      );\r\n    }, this.dragVertexDelay_);\r\n    this.downPx_ = event.pixel;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  deactivateTrace_() {\r\n    this.traceState_ = {active: false};\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate trace state based on a browser event.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @private\r\n   */\r\n  toggleTraceState_(event) {\r\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\r\n      return;\r\n    }\r\n\r\n    if (this.traceState_.active) {\r\n      this.deactivateTrace_();\r\n      return;\r\n    }\r\n\r\n    const map = this.getMap();\r\n    const lowerLeft = map.getCoordinateFromPixel([\r\n      event.pixel[0] - this.snapTolerance_,\r\n      event.pixel[1] + this.snapTolerance_,\r\n    ]);\r\n    const upperRight = map.getCoordinateFromPixel([\r\n      event.pixel[0] + this.snapTolerance_,\r\n      event.pixel[1] - this.snapTolerance_,\r\n    ]);\r\n    const extent = boundingExtent([lowerLeft, upperRight]);\r\n    const features = this.traceSource_.getFeaturesInExtent(extent);\r\n    if (features.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const targets = getTraceTargets(event.coordinate, features);\r\n    if (targets.length) {\r\n      this.traceState_ = {\r\n        active: true,\r\n        startPx: event.pixel.slice(),\r\n        targets: targets,\r\n        targetIndex: -1,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {TraceTarget} target The trace target.\r\n   * @param {number} endIndex The new end index of the trace.\r\n   * @private\r\n   */\r\n  addOrRemoveTracedCoordinates_(target, endIndex) {\r\n    // three cases to handle:\r\n    //  1. traced in the same direction and points need adding\r\n    //  2. traced in the same direction and points need removing\r\n    //  3. traced in a new direction\r\n    const previouslyForward = target.startIndex <= target.endIndex;\r\n    const currentlyForward = target.startIndex <= endIndex;\r\n    if (previouslyForward === currentlyForward) {\r\n      // same direction\r\n      if (\r\n        (previouslyForward && endIndex > target.endIndex) ||\r\n        (!previouslyForward && endIndex < target.endIndex)\r\n      ) {\r\n        // case 1 - add new points\r\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\r\n      } else if (\r\n        (previouslyForward && endIndex < target.endIndex) ||\r\n        (!previouslyForward && endIndex > target.endIndex)\r\n      ) {\r\n        // case 2 - remove old points\r\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\r\n      }\r\n    } else {\r\n      // case 3 - remove old points, add new points\r\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\r\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} fromIndex The start index.\r\n   * @param {number} toIndex The end index.\r\n   * @private\r\n   */\r\n  removeTracedCoordinates_(fromIndex, toIndex) {\r\n    if (fromIndex === toIndex) {\r\n      return;\r\n    }\r\n\r\n    let remove = 0;\r\n    if (fromIndex < toIndex) {\r\n      const start = Math.ceil(fromIndex);\r\n      let end = Math.floor(toIndex);\r\n      if (end === toIndex) {\r\n        end -= 1;\r\n      }\r\n      remove = end - start + 1;\r\n    } else {\r\n      const start = Math.floor(fromIndex);\r\n      let end = Math.ceil(toIndex);\r\n      if (end === toIndex) {\r\n        end += 1;\r\n      }\r\n      remove = start - end + 1;\r\n    }\r\n\r\n    if (remove > 0) {\r\n      this.removeLastPoints_(remove);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {TraceTarget} target The trace target.\r\n   * @param {number} fromIndex The start index.\r\n   * @param {number} toIndex The end index.\r\n   * @private\r\n   */\r\n  addTracedCoordinates_(target, fromIndex, toIndex) {\r\n    if (fromIndex === toIndex) {\r\n      return;\r\n    }\r\n\r\n    const coordinates = [];\r\n    if (fromIndex < toIndex) {\r\n      // forward trace\r\n      const start = Math.ceil(fromIndex);\r\n      let end = Math.floor(toIndex);\r\n      if (end === toIndex) {\r\n        // if end is snapped to a vertex, it will be added later\r\n        end -= 1;\r\n      }\r\n      for (let i = start; i <= end; ++i) {\r\n        coordinates.push(getCoordinate(target.coordinates, i));\r\n      }\r\n    } else {\r\n      // reverse trace\r\n      const start = Math.floor(fromIndex);\r\n      let end = Math.ceil(toIndex);\r\n      if (end === toIndex) {\r\n        end += 1;\r\n      }\r\n      for (let i = start; i >= end; --i) {\r\n        coordinates.push(getCoordinate(target.coordinates, i));\r\n      }\r\n    }\r\n    if (coordinates.length) {\r\n      this.appendCoordinates(coordinates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the trace.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @private\r\n   */\r\n  updateTrace_(event) {\r\n    const traceState = this.traceState_;\r\n    if (!traceState.active) {\r\n      return;\r\n    }\r\n\r\n    if (traceState.targetIndex === -1) {\r\n      // check if we are ready to pick a target\r\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const updatedTraceTarget = getTraceTargetUpdate(\r\n      event.coordinate,\r\n      traceState,\r\n      this.getMap(),\r\n      this.snapTolerance_,\r\n    );\r\n\r\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\r\n      // target changed\r\n      if (traceState.targetIndex !== -1) {\r\n        // remove points added during previous trace\r\n        const oldTarget = traceState.targets[traceState.targetIndex];\r\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\r\n      }\r\n      // add points for the new target\r\n      const newTarget = traceState.targets[updatedTraceTarget.index];\r\n      this.addTracedCoordinates_(\r\n        newTarget,\r\n        newTarget.startIndex,\r\n        updatedTraceTarget.endIndex,\r\n      );\r\n    } else {\r\n      // target stayed the same\r\n      const target = traceState.targets[traceState.targetIndex];\r\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\r\n    }\r\n\r\n    // modify the state with updated info\r\n    traceState.targetIndex = updatedTraceTarget.index;\r\n    const target = traceState.targets[traceState.targetIndex];\r\n    target.endIndex = updatedTraceTarget.endIndex;\r\n\r\n    // update event coordinate and pixel to match end point of final segment\r\n    const coordinate = interpolateCoordinate(\r\n      target.coordinates,\r\n      target.endIndex,\r\n    );\r\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\r\n    event.coordinate = coordinate;\r\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\r\n  handleUpEvent(event) {\r\n    let pass = true;\r\n\r\n    if (this.getPointerCount() === 0) {\r\n      if (this.downTimeout_) {\r\n        clearTimeout(this.downTimeout_);\r\n        this.downTimeout_ = undefined;\r\n      }\r\n\r\n      this.handlePointerMove_(event);\r\n      const tracing = this.traceState_.active;\r\n      this.toggleTraceState_(event);\r\n\r\n      if (this.shouldHandle_) {\r\n        const startingToDraw = !this.finishCoordinate_;\r\n        if (startingToDraw) {\r\n          this.startDrawing_(event.coordinate);\r\n        }\r\n        if (!startingToDraw && this.freehand_) {\r\n          this.finishDrawing();\r\n        } else if (\r\n          !this.freehand_ &&\r\n          (!startingToDraw || this.mode_ === 'Point')\r\n        ) {\r\n          if (this.atFinish_(event.pixel, tracing)) {\r\n            if (this.finishCondition_(event)) {\r\n              this.finishDrawing();\r\n            }\r\n          } else {\r\n            this.addToDrawing_(event.coordinate);\r\n          }\r\n        }\r\n        pass = false;\r\n      } else if (this.freehand_) {\r\n        this.abortDrawing();\r\n      }\r\n    }\r\n\r\n    if (!pass && this.stopClick_) {\r\n      event.preventDefault();\r\n    }\r\n    return pass;\r\n  }\r\n\r\n  /**\r\n   * Handle move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\r\n   * @private\r\n   */\r\n  handlePointerMove_(event) {\r\n    this.pointerType_ = event.originalEvent.pointerType;\r\n    if (\r\n      this.downPx_ &&\r\n      ((!this.freehand_ && this.shouldHandle_) ||\r\n        (this.freehand_ && !this.shouldHandle_))\r\n    ) {\r\n      const downPx = this.downPx_;\r\n      const clickPx = event.pixel;\r\n      const dx = downPx[0] - clickPx[0];\r\n      const dy = downPx[1] - clickPx[1];\r\n      const squaredDistance = dx * dx + dy * dy;\r\n      this.shouldHandle_ = this.freehand_\r\n        ? squaredDistance > this.squaredClickTolerance_\r\n        : squaredDistance <= this.squaredClickTolerance_;\r\n      if (!this.shouldHandle_) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (!this.finishCoordinate_) {\r\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\r\n      return;\r\n    }\r\n\r\n    this.updateTrace_(event);\r\n    this.modifyDrawing_(event.coordinate);\r\n  }\r\n\r\n  /**\r\n   * Determine if an event is within the snapping tolerance of the start coord.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\r\n   * @return {boolean} The event is within the snapping tolerance of the start.\r\n   * @private\r\n   */\r\n  atFinish_(pixel, tracing) {\r\n    let at = false;\r\n    if (this.sketchFeature_) {\r\n      let potentiallyDone = false;\r\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\r\n      const mode = this.mode_;\r\n      if (mode === 'Point') {\r\n        at = true;\r\n      } else if (mode === 'Circle') {\r\n        at = this.sketchCoords_.length === 2;\r\n      } else if (mode === 'LineString') {\r\n        potentiallyDone =\r\n          !tracing && this.sketchCoords_.length > this.minPoints_;\r\n      } else if (mode === 'Polygon') {\r\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\r\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\r\n        potentiallyFinishCoordinates = [\r\n          sketchCoords[0][0],\r\n          sketchCoords[0][sketchCoords[0].length - 2],\r\n        ];\r\n        if (tracing) {\r\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\r\n        } else {\r\n          potentiallyFinishCoordinates = [\r\n            sketchCoords[0][0],\r\n            sketchCoords[0][sketchCoords[0].length - 2],\r\n          ];\r\n        }\r\n      }\r\n      if (potentiallyDone) {\r\n        const map = this.getMap();\r\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\r\n          const finishCoordinate = potentiallyFinishCoordinates[i];\r\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\r\n          const dx = pixel[0] - finishPixel[0];\r\n          const dy = pixel[1] - finishPixel[1];\r\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\r\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\r\n          if (at) {\r\n            this.finishCoordinate_ = finishCoordinate;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return at;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\r\n   * @private\r\n   */\r\n  createOrUpdateSketchPoint_(coordinates) {\r\n    if (!this.sketchPoint_) {\r\n      this.sketchPoint_ = new Feature(new Point(coordinates));\r\n      this.updateSketchFeatures_();\r\n    } else {\r\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\r\n      sketchPointGeom.setCoordinates(coordinates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\r\n   * @private\r\n   */\r\n  createOrUpdateCustomSketchLine_(geometry) {\r\n    if (!this.sketchLine_) {\r\n      this.sketchLine_ = new Feature();\r\n    }\r\n    const ring = geometry.getLinearRing(0);\r\n    let sketchLineGeom = this.sketchLine_.getGeometry();\r\n    if (!sketchLineGeom) {\r\n      sketchLineGeom = new LineString(\r\n        ring.getFlatCoordinates(),\r\n        ring.getLayout(),\r\n      );\r\n      this.sketchLine_.setGeometry(sketchLineGeom);\r\n    } else {\r\n      sketchLineGeom.setFlatCoordinates(\r\n        ring.getLayout(),\r\n        ring.getFlatCoordinates(),\r\n      );\r\n      sketchLineGeom.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start the drawing.\r\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\r\n   * @private\r\n   */\r\n  startDrawing_(start) {\r\n    const projection = this.getMap().getView().getProjection();\r\n    const stride = getStrideForLayout(this.geometryLayout_);\r\n    while (start.length < stride) {\r\n      start.push(0);\r\n    }\r\n    this.finishCoordinate_ = start;\r\n    if (this.mode_ === 'Point') {\r\n      this.sketchCoords_ = start.slice();\r\n    } else if (this.mode_ === 'Polygon') {\r\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\r\n      this.sketchLineCoords_ = this.sketchCoords_[0];\r\n    } else {\r\n      this.sketchCoords_ = [start.slice(), start.slice()];\r\n    }\r\n    if (this.sketchLineCoords_) {\r\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\r\n    }\r\n    const geometry = this.geometryFunction_(\r\n      this.sketchCoords_,\r\n      undefined,\r\n      projection,\r\n    );\r\n    this.sketchFeature_ = new Feature();\r\n    if (this.geometryName_) {\r\n      this.sketchFeature_.setGeometryName(this.geometryName_);\r\n    }\r\n    this.sketchFeature_.setGeometry(geometry);\r\n    this.updateSketchFeatures_();\r\n    this.dispatchEvent(\r\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Modify the drawing.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @private\r\n   */\r\n  modifyDrawing_(coordinate) {\r\n    const map = this.getMap();\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = map.getView().getProjection();\r\n    const stride = getStrideForLayout(this.geometryLayout_);\r\n    let coordinates, last;\r\n    while (coordinate.length < stride) {\r\n      coordinate.push(0);\r\n    }\r\n    if (this.mode_ === 'Point') {\r\n      last = this.sketchCoords_;\r\n    } else if (this.mode_ === 'Polygon') {\r\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n      last = coordinates[coordinates.length - 1];\r\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\r\n        // snap to finish\r\n        coordinate = this.finishCoordinate_.slice();\r\n      }\r\n    } else {\r\n      coordinates = this.sketchCoords_;\r\n      last = coordinates[coordinates.length - 1];\r\n    }\r\n    last[0] = coordinate[0];\r\n    last[1] = coordinate[1];\r\n    this.geometryFunction_(\r\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\r\n      geometry,\r\n      projection,\r\n    );\r\n    if (this.sketchPoint_) {\r\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\r\n      sketchPointGeom.setCoordinates(coordinate);\r\n    }\r\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\r\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\r\n    } else if (this.sketchLineCoords_) {\r\n      const sketchLineGeom = this.sketchLine_.getGeometry();\r\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\r\n    }\r\n    this.updateSketchFeatures_();\r\n  }\r\n\r\n  /**\r\n   * Add a new coordinate to the drawing.\r\n   * @param {!PointCoordType} coordinate Coordinate\r\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\r\n   * @private\r\n   */\r\n  addToDrawing_(coordinate) {\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    let done;\r\n    let coordinates;\r\n    const mode = this.mode_;\r\n    if (mode === 'LineString' || mode === 'Circle') {\r\n      this.finishCoordinate_ = coordinate.slice();\r\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n      if (coordinates.length >= this.maxPoints_) {\r\n        if (this.freehand_) {\r\n          coordinates.pop();\r\n        } else {\r\n          done = true;\r\n        }\r\n      }\r\n      coordinates.push(coordinate.slice());\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n    } else if (mode === 'Polygon') {\r\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n      if (coordinates.length >= this.maxPoints_) {\r\n        if (this.freehand_) {\r\n          coordinates.pop();\r\n        } else {\r\n          done = true;\r\n        }\r\n      }\r\n      coordinates.push(coordinate.slice());\r\n      if (done) {\r\n        this.finishCoordinate_ = coordinates[0];\r\n      }\r\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\r\n    }\r\n    this.createOrUpdateSketchPoint_(coordinate.slice());\r\n    this.updateSketchFeatures_();\r\n    if (done) {\r\n      return this.finishDrawing();\r\n    }\r\n    return this.sketchFeature_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} n The number of points to remove.\r\n   */\r\n  removeLastPoints_(n) {\r\n    if (!this.sketchFeature_) {\r\n      return;\r\n    }\r\n    const geometry = this.sketchFeature_.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    const mode = this.mode_;\r\n    for (let i = 0; i < n; ++i) {\r\n      let coordinates;\r\n      if (mode === 'LineString' || mode === 'Circle') {\r\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n        coordinates.splice(-2, 1);\r\n        if (coordinates.length >= 2) {\r\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\r\n          const finishCoordinate = this.finishCoordinate_.slice();\r\n          coordinates[coordinates.length - 1] = finishCoordinate;\r\n          this.createOrUpdateSketchPoint_(finishCoordinate);\r\n        }\r\n        this.geometryFunction_(coordinates, geometry, projection);\r\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\r\n          this.createOrUpdateCustomSketchLine_(\r\n            /** @type {Polygon} */ (geometry),\r\n          );\r\n        }\r\n      } else if (mode === 'Polygon') {\r\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\r\n        coordinates.splice(-2, 1);\r\n        const sketchLineGeom = this.sketchLine_.getGeometry();\r\n        if (coordinates.length >= 2) {\r\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\r\n          coordinates[coordinates.length - 1] = finishCoordinate;\r\n          this.createOrUpdateSketchPoint_(finishCoordinate);\r\n        }\r\n        sketchLineGeom.setCoordinates(coordinates);\r\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\r\n      }\r\n\r\n      if (coordinates.length === 1) {\r\n        this.abortDrawing();\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.updateSketchFeatures_();\r\n  }\r\n\r\n  /**\r\n   * Remove last point of the feature currently being drawn. Does not do anything when\r\n   * drawing POINT or MULTI_POINT geometries.\r\n   * @api\r\n   */\r\n  removeLastPoint() {\r\n    this.removeLastPoints_(1);\r\n  }\r\n\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target layer.\r\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\r\n   * dispatched before inserting the feature.\r\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\r\n   * @api\r\n   */\r\n  finishDrawing() {\r\n    const sketchFeature = this.abortDrawing_();\r\n    if (!sketchFeature) {\r\n      return null;\r\n    }\r\n    let coordinates = this.sketchCoords_;\r\n    const geometry = sketchFeature.getGeometry();\r\n    const projection = this.getMap().getView().getProjection();\r\n    if (this.mode_ === 'LineString') {\r\n      // remove the redundant last point\r\n      coordinates.pop();\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n    } else if (this.mode_ === 'Polygon') {\r\n      // remove the redundant last point in ring\r\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\r\n      this.geometryFunction_(coordinates, geometry, projection);\r\n      coordinates = geometry.getCoordinates();\r\n    }\r\n\r\n    // cast multi-part geometries\r\n    if (this.type_ === 'MultiPoint') {\r\n      sketchFeature.setGeometry(\r\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\r\n      );\r\n    } else if (this.type_ === 'MultiLineString') {\r\n      sketchFeature.setGeometry(\r\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\r\n      );\r\n    } else if (this.type_ === 'MultiPolygon') {\r\n      sketchFeature.setGeometry(\r\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\r\n      );\r\n    }\r\n\r\n    // First dispatch event to allow full set up of feature\r\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\r\n\r\n    // Then insert feature\r\n    if (this.features_) {\r\n      this.features_.push(sketchFeature);\r\n    }\r\n    if (this.source_) {\r\n      this.source_.addFeature(sketchFeature);\r\n    }\r\n    return sketchFeature;\r\n  }\r\n\r\n  /**\r\n   * Stop drawing without adding the sketch feature to the target layer.\r\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\r\n   * @private\r\n   */\r\n  abortDrawing_() {\r\n    this.finishCoordinate_ = null;\r\n    const sketchFeature = this.sketchFeature_;\r\n    this.sketchFeature_ = null;\r\n    this.sketchPoint_ = null;\r\n    this.sketchLine_ = null;\r\n    this.overlay_.getSource().clear(true);\r\n    this.deactivateTrace_();\r\n    return sketchFeature;\r\n  }\r\n\r\n  /**\r\n   * Stop drawing without adding the sketch feature to the target layer.\r\n   * @api\r\n   */\r\n  abortDrawing() {\r\n    const sketchFeature = this.abortDrawing_();\r\n    if (sketchFeature) {\r\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append coordinates to the end of the geometry that is currently being drawn.\r\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\r\n   * either be appended to the current LineString or the outer ring of the current\r\n   * Polygon. If no geometry is being drawn, a new one will be created.\r\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\r\n   * the coordinate array.\r\n   * @api\r\n   */\r\n  appendCoordinates(coordinates) {\r\n    const mode = this.mode_;\r\n    const newDrawing = !this.sketchFeature_;\r\n    if (newDrawing) {\r\n      this.startDrawing_(coordinates[0]);\r\n    }\r\n    /** @type {LineCoordType} */\r\n    let sketchCoords;\r\n    if (mode === 'LineString' || mode === 'Circle') {\r\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\r\n    } else if (mode === 'Polygon') {\r\n      sketchCoords =\r\n        this.sketchCoords_ && this.sketchCoords_.length\r\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\r\n          : [];\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (newDrawing) {\r\n      sketchCoords.shift();\r\n    }\r\n\r\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\r\n    sketchCoords.pop();\r\n\r\n    // Append coordinate list\r\n    for (let i = 0; i < coordinates.length; i++) {\r\n      this.addToDrawing_(coordinates[i]);\r\n    }\r\n\r\n    const ending = coordinates[coordinates.length - 1];\r\n    // Duplicate last coordinate for sketch drawing (cursor position)\r\n    this.sketchFeature_ = this.addToDrawing_(ending);\r\n    this.modifyDrawing_(ending);\r\n  }\r\n\r\n  /**\r\n   * Initiate draw mode by starting from an existing geometry which will\r\n   * receive new additional points. This only works on features with\r\n   * `LineString` geometries, where the interaction will extend lines by adding\r\n   * points to the end of the coordinates array.\r\n   * This will change the original feature, instead of drawing a copy.\r\n   *\r\n   * The function will dispatch a `drawstart` event.\r\n   *\r\n   * @param {!Feature<LineString>} feature Feature to be extended.\r\n   * @api\r\n   */\r\n  extend(feature) {\r\n    const geometry = feature.getGeometry();\r\n    const lineString = geometry;\r\n    this.sketchFeature_ = feature;\r\n    this.sketchCoords_ = lineString.getCoordinates();\r\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\r\n    this.finishCoordinate_ = last.slice();\r\n    this.sketchCoords_.push(last.slice());\r\n    this.sketchPoint_ = new Feature(new Point(last));\r\n    this.updateSketchFeatures_();\r\n    this.dispatchEvent(\r\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Redraw the sketch features.\r\n   * @private\r\n   */\r\n  updateSketchFeatures_() {\r\n    const sketchFeatures = [];\r\n    if (this.sketchFeature_) {\r\n      sketchFeatures.push(this.sketchFeature_);\r\n    }\r\n    if (this.sketchLine_) {\r\n      sketchFeatures.push(this.sketchLine_);\r\n    }\r\n    if (this.sketchPoint_) {\r\n      sketchFeatures.push(this.sketchPoint_);\r\n    }\r\n    const overlaySource = this.overlay_.getSource();\r\n    overlaySource.clear(true);\r\n    overlaySource.addFeatures(sketchFeatures);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateState_() {\r\n    const map = this.getMap();\r\n    const active = this.getActive();\r\n    if (!map || !active) {\r\n      this.abortDrawing();\r\n    }\r\n    this.overlay_.setMap(active ? map : null);\r\n  }\r\n}\r\n\r\n/**\r\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\r\n */\r\nfunction getDefaultStyleFunction() {\r\n  const styles = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return styles[feature.getGeometry().getType()];\r\n  };\r\n}\r\n\r\n/**\r\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\r\n * polygon with a user specified number of sides and start angle instead of a\r\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\r\n * @param {number} [sides] Number of sides of the regular polygon.\r\n *     Default is 32.\r\n * @param {number} [angle] Angle of the first point in counter-clockwise\r\n *     radians. 0 means East.\r\n *     Default is the angle defined by the heading from the center of the\r\n *     regular polygon to the current pointer position.\r\n * @return {GeometryFunction} Function that draws a polygon.\r\n * @api\r\n */\r\nexport function createRegularPolygon(sides, angle) {\r\n  return function (coordinates, geometry, projection) {\r\n    const center = fromUserCoordinate(\r\n      /** @type {LineCoordType} */ (coordinates)[0],\r\n      projection,\r\n    );\r\n    const end = fromUserCoordinate(\r\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\r\n      projection,\r\n    );\r\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\r\n    geometry = geometry || fromCircle(new Circle(center), sides);\r\n\r\n    let internalAngle = angle;\r\n    if (!angle && angle !== 0) {\r\n      const x = end[0] - center[0];\r\n      const y = end[1] - center[1];\r\n      internalAngle = Math.atan2(y, x);\r\n    }\r\n    makeRegular(\r\n      /** @type {Polygon} */ (geometry),\r\n      center,\r\n      radius,\r\n      internalAngle,\r\n    );\r\n\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      geometry.transform(projection, userProjection);\r\n    }\r\n    return geometry;\r\n  };\r\n}\r\n\r\n/**\r\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\r\n * with the coordinate system axes).  Use this with the draw interaction and\r\n * `type: 'Circle'` to return a box instead of a circle geometry.\r\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\r\n * @api\r\n */\r\nexport function createBox() {\r\n  return function (coordinates, geometry, projection) {\r\n    const extent = boundingExtent(\r\n      /** @type {LineCoordType} */ ([\r\n        coordinates[0],\r\n        coordinates[coordinates.length - 1],\r\n      ]).map(function (coordinate) {\r\n        return fromUserCoordinate(coordinate, projection);\r\n      }),\r\n    );\r\n    const boxCoordinates = [\r\n      [\r\n        getBottomLeft(extent),\r\n        getBottomRight(extent),\r\n        getTopRight(extent),\r\n        getTopLeft(extent),\r\n        getBottomLeft(extent),\r\n      ],\r\n    ];\r\n    if (geometry) {\r\n      geometry.setCoordinates(boxCoordinates);\r\n    } else {\r\n      geometry = new Polygon(boxCoordinates);\r\n    }\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      geometry.transform(projection, userProjection);\r\n    }\r\n    return geometry;\r\n  };\r\n}\r\n\r\n/**\r\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\r\n * their single-part cousins.\r\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\r\n * @return {Mode} Drawing mode.\r\n */\r\nfunction getMode(type) {\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n      return 'Point';\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n      return 'LineString';\r\n    case 'Polygon':\r\n    case 'MultiPolygon':\r\n      return 'Polygon';\r\n    case 'Circle':\r\n      return 'Circle';\r\n    default:\r\n      throw new Error('Invalid type: ' + type);\r\n  }\r\n}\r\n\r\nexport default Draw;\r\n"],
  "mappings": "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",
  "names": ["squaredDistance", "Vector_default", "target"]
}
