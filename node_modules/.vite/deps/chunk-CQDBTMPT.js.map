{
  "version": 3,
  "sources": ["../../ol/format/Feature.js"],
  "sourcesContent": ["/**\r\n * @module ol/format/Feature\r\n */\r\nimport Feature from '../Feature.js';\r\nimport RenderFeature from '../render/Feature.js';\r\nimport {\r\n  GeometryCollection,\r\n  LineString,\r\n  MultiLineString,\r\n  MultiPoint,\r\n  MultiPolygon,\r\n  Point,\r\n  Polygon,\r\n} from '../geom.js';\r\nimport {abstract} from '../util.js';\r\nimport {\r\n  equivalent as equivalentProjection,\r\n  get as getProjection,\r\n  getTransform,\r\n  transformExtent,\r\n} from '../proj.js';\r\nimport {\r\n  linearRingsAreOriented,\r\n  linearRingssAreOriented,\r\n  orientLinearRings,\r\n  orientLinearRingsArray,\r\n} from '../geom/flat/orient.js';\r\n\r\n/**\r\n * @typedef {Object} ReadOptions\r\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\r\n * If not provided, the projection will be derived from the data (where possible) or\r\n * the `dataProjection` of the format is assigned (where set). If the projection\r\n * can not be derived from the data and if no `dataProjection` is set for a format,\r\n * the features will not be reprojected.\r\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\r\n * This is only required when reading data with tile pixels as geometry units. When configured,\r\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\r\n * provided.\r\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\r\n * created by the format reader. If not provided, features will be returned in the\r\n * `dataProjection`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} WriteOptions\r\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\r\n * If not provided, the `dataProjection` of the format is assigned (where set).\r\n * If no `dataProjection` is set for a format, the features will be returned\r\n * in the `featureProjection`.\r\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\r\n * that will be serialized by the format writer. If not provided, geometries are assumed\r\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\r\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\r\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\r\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\r\n * as they are provided at construction.  If `true`, the right-hand rule will\r\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\r\n * exterior and counter-clockwise for interior rings).  Note that not all\r\n * formats support this.  The GeoJSON format does use this property when writing\r\n * geometries.\r\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\r\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\r\n * coordinates with a large number of decimal places, not generally wanted on output.\r\n * Set a number here to round coordinates. Can also be used to ensure that\r\n * coordinates read in can be written back out with the same number of decimals.\r\n * Default is no rounding.\r\n */\r\n\r\n/**\r\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\r\n */\r\n\r\n/**\r\n * @typedef {Object} SimpleGeometryObject\r\n * @property {import('../geom/Geometry.js').Type} type Type.\r\n * @property {Array<number>} flatCoordinates Flat coordinates.\r\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\r\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\r\n */\r\n\r\n/**\r\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\r\n */\r\n\r\n/**\r\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\r\n */\r\n\r\n/**\r\n * @typedef {Object} FeatureObject\r\n * @property {string|number} [id] Id.\r\n * @property {GeometryObject} [geometry] Geometry.\r\n * @property {Object<string, *>} [properties] Properties.\r\n */\r\n\r\n/***\r\n * @template {import('../Feature.js').FeatureLike} T\r\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\r\n */\r\n\r\n/***\r\n * @template {import(\"../Feature.js\").FeatureClass} T\r\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for feature formats.\r\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\r\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\r\n * file formats.  See the documentation for each format for more details.\r\n *\r\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\r\n * @abstract\r\n * @api\r\n */\r\nclass FeatureFormat {\r\n  constructor() {\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../proj/Projection.js\").default|undefined}\r\n     */\r\n    this.dataProjection = undefined;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../proj/Projection.js\").default|undefined}\r\n     */\r\n    this.defaultFeatureProjection = undefined;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {FeatureToFeatureClass<FeatureType>}\r\n     */\r\n    this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */ (\r\n      Feature\r\n    );\r\n\r\n    /**\r\n     * A list media types supported by the format in descending order of preference.\r\n     * @type {Array<string>}\r\n     */\r\n    this.supportedMediaTypes = null;\r\n  }\r\n\r\n  /**\r\n   * Adds the data projection to the read options.\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {ReadOptions} [options] Options.\r\n   * @return {ReadOptions|undefined} Options.\r\n   * @protected\r\n   */\r\n  getReadOptions(source, options) {\r\n    if (options) {\r\n      let dataProjection = options.dataProjection\r\n        ? getProjection(options.dataProjection)\r\n        : this.readProjection(source);\r\n      if (\r\n        options.extent &&\r\n        dataProjection &&\r\n        dataProjection.getUnits() === 'tile-pixels'\r\n      ) {\r\n        dataProjection = getProjection(dataProjection);\r\n        dataProjection.setWorldExtent(options.extent);\r\n      }\r\n      options = {\r\n        dataProjection: dataProjection,\r\n        featureProjection: options.featureProjection,\r\n      };\r\n    }\r\n    return this.adaptOptions(options);\r\n  }\r\n\r\n  /**\r\n   * Sets the `dataProjection` on the options, if no `dataProjection`\r\n   * is set.\r\n   * @param {WriteOptions|ReadOptions|undefined} options\r\n   *     Options.\r\n   * @protected\r\n   * @return {WriteOptions|ReadOptions|undefined}\r\n   *     Updated options.\r\n   */\r\n  adaptOptions(options) {\r\n    return Object.assign(\r\n      {\r\n        dataProjection: this.dataProjection,\r\n        featureProjection: this.defaultFeatureProjection,\r\n        featureClass: this.featureClass,\r\n      },\r\n      options,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {Type} The format type.\r\n   */\r\n  getType() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read a single feature from a source.\r\n   *\r\n   * @abstract\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {ReadOptions} [options] Read options.\r\n   * @return {FeatureType|Array<FeatureType>} Feature.\r\n   */\r\n  readFeature(source, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read all features from a source.\r\n   *\r\n   * @abstract\r\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\r\n   * @param {ReadOptions} [options] Read options.\r\n   * @return {Array<FeatureType>} Features.\r\n   */\r\n  readFeatures(source, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read a single geometry from a source.\r\n   *\r\n   * @abstract\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @param {ReadOptions} [options] Read options.\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometry(source, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Read the projection from a source.\r\n   *\r\n   * @abstract\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\r\n   */\r\n  readProjection(source) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Encode a feature in this format.\r\n   *\r\n   * @abstract\r\n   * @param {Feature} feature Feature.\r\n   * @param {WriteOptions} [options] Write options.\r\n   * @return {string|ArrayBuffer} Result.\r\n   */\r\n  writeFeature(feature, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Encode an array of features in this format.\r\n   *\r\n   * @abstract\r\n   * @param {Array<Feature>} features Features.\r\n   * @param {WriteOptions} [options] Write options.\r\n   * @return {string|ArrayBuffer} Result.\r\n   */\r\n  writeFeatures(features, options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Write a single geometry in this format.\r\n   *\r\n   * @abstract\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {WriteOptions} [options] Write options.\r\n   * @return {string|ArrayBuffer} Result.\r\n   */\r\n  writeGeometry(geometry, options) {\r\n    return abstract();\r\n  }\r\n}\r\n\r\nexport default FeatureFormat;\r\n\r\n/**\r\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\r\n * @param {T} geometry Geometry.\r\n * @param {boolean} write Set to true for writing, false for reading.\r\n * @param {WriteOptions|ReadOptions} [options] Options.\r\n * @return {T} Transformed geometry.\r\n */\r\nexport function transformGeometryWithOptions(geometry, write, options) {\r\n  const featureProjection = options\r\n    ? getProjection(options.featureProjection)\r\n    : null;\r\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\r\n\r\n  let transformed = geometry;\r\n  if (\r\n    featureProjection &&\r\n    dataProjection &&\r\n    !equivalentProjection(featureProjection, dataProjection)\r\n  ) {\r\n    if (write) {\r\n      transformed = /** @type {T} */ (geometry.clone());\r\n    }\r\n    const fromProjection = write ? featureProjection : dataProjection;\r\n    const toProjection = write ? dataProjection : featureProjection;\r\n    if (fromProjection.getUnits() === 'tile-pixels') {\r\n      transformed.transform(fromProjection, toProjection);\r\n    } else {\r\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\r\n    }\r\n  }\r\n  if (\r\n    write &&\r\n    options &&\r\n    /** @type {WriteOptions} */ (options).decimals !== undefined\r\n  ) {\r\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\r\n    // if decimals option on write, round each coordinate appropriately\r\n    /**\r\n     * @param {Array<number>} coordinates Coordinates.\r\n     * @return {Array<number>} Transformed coordinates.\r\n     */\r\n    const transform = function (coordinates) {\r\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\r\n      }\r\n      return coordinates;\r\n    };\r\n    if (transformed === geometry) {\r\n      transformed = /** @type {T} */ (geometry.clone());\r\n    }\r\n    transformed.applyTransform(transform);\r\n  }\r\n  return transformed;\r\n}\r\n\r\n/**\r\n * @param {import(\"../extent.js\").Extent} extent Extent.\r\n * @param {ReadOptions} [options] Read options.\r\n * @return {import(\"../extent.js\").Extent} Transformed extent.\r\n */\r\nexport function transformExtentWithOptions(extent, options) {\r\n  const featureProjection = options\r\n    ? getProjection(options.featureProjection)\r\n    : null;\r\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\r\n\r\n  if (\r\n    featureProjection &&\r\n    dataProjection &&\r\n    !equivalentProjection(featureProjection, dataProjection)\r\n  ) {\r\n    return transformExtent(extent, dataProjection, featureProjection);\r\n  }\r\n  return extent;\r\n}\r\n\r\nconst GeometryConstructor = {\r\n  Point: Point,\r\n  LineString: LineString,\r\n  Polygon: Polygon,\r\n  MultiPoint: MultiPoint,\r\n  MultiLineString: MultiLineString,\r\n  MultiPolygon: MultiPolygon,\r\n};\r\n\r\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\r\n  if (Array.isArray(ends[0])) {\r\n    // MultiPolagon\r\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\r\n      flatCoordinates = flatCoordinates.slice();\r\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\r\n    }\r\n    return flatCoordinates;\r\n  }\r\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\r\n    flatCoordinates = flatCoordinates.slice();\r\n    orientLinearRings(flatCoordinates, 0, ends, stride);\r\n  }\r\n  return flatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {FeatureObject} object Feature object.\r\n * @param {WriteOptions|ReadOptions} [options] Options.\r\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\r\n */\r\nexport function createRenderFeature(object, options) {\r\n  const geometry = object.geometry;\r\n  if (!geometry) {\r\n    return [];\r\n  }\r\n  if (Array.isArray(geometry)) {\r\n    return geometry\r\n      .map((geometry) => createRenderFeature({...object, geometry}))\r\n      .flat();\r\n  }\r\n\r\n  const geometryType =\r\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\r\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\r\n    throw new Error('Unsupported geometry type: ' + geometryType);\r\n  }\r\n\r\n  const stride = geometry.layout.length;\r\n  return transformGeometryWithOptions(\r\n    new RenderFeature(\r\n      geometryType,\r\n      geometryType === 'Polygon'\r\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\r\n        : geometry.flatCoordinates,\r\n      geometry.ends?.flat(),\r\n      stride,\r\n      object.properties || {},\r\n      object.id,\r\n    ).enableSimplifyTransformed(),\r\n    false,\r\n    options,\r\n  );\r\n}\r\n\r\n/**\r\n * @param {GeometryObject|null} object Geometry object.\r\n * @param {WriteOptions|ReadOptions} [options] Options.\r\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n */\r\nexport function createGeometry(object, options) {\r\n  if (!object) {\r\n    return null;\r\n  }\r\n  if (Array.isArray(object)) {\r\n    const geometries = object.map((geometry) =>\r\n      createGeometry(geometry, options),\r\n    );\r\n    return new GeometryCollection(geometries);\r\n  }\r\n  const Geometry = GeometryConstructor[object.type];\r\n  return transformGeometryWithOptions(\r\n    new Geometry(object.flatCoordinates, object.layout, object.ends),\r\n    false,\r\n    options,\r\n  );\r\n}\r\n"],
  "mappings": "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",
  "names": ["Feature_default", "geometry", "Feature_default"]
}
