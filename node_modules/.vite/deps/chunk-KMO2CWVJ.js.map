{
  "version": 3,
  "sources": ["../../ol/geom/flat/inflate.js", "../../ol/geom/flat/closest.js", "../../ol/geom/flat/simplify.js", "../../ol/geom/flat/area.js", "../../ol/geom/LinearRing.js", "../../ol/geom/flat/interiorpoint.js", "../../ol/geom/flat/reverse.js", "../../ol/geom/flat/orient.js", "../../ol/geom/Polygon.js"],
  "sourcesContent": ["/**\r\n * @module ol/geom/flat/inflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\r\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\r\n */\r\nexport function inflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  coordinates,\r\n) {\r\n  coordinates = coordinates !== undefined ? coordinates : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\r\n  }\r\n  coordinates.length = i;\r\n  return coordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\r\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\r\n */\r\nexport function inflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  coordinatess,\r\n) {\r\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n    const end = ends[j];\r\n    coordinatess[i++] = inflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      coordinatess[i],\r\n    );\r\n    offset = end;\r\n  }\r\n  coordinatess.length = i;\r\n  return coordinatess;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\r\n *     Coordinatesss.\r\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\r\n */\r\nexport function inflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  coordinatesss,\r\n) {\r\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\r\n    const ends = endss[j];\r\n    coordinatesss[i++] =\r\n      ends.length === 1 && ends[0] === offset\r\n        ? []\r\n        : inflateCoordinatesArray(\r\n            flatCoordinates,\r\n            offset,\r\n            ends,\r\n            stride,\r\n            coordinatesss[i],\r\n          );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  coordinatesss.length = i;\r\n  return coordinatesss;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/closest\r\n */\r\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\r\n\r\n/**\r\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\r\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\r\n * dimensions are linearly interpolated.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset1 Offset 1.\r\n * @param {number} offset2 Offset 2.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n */\r\nfunction assignClosest(\r\n  flatCoordinates,\r\n  offset1,\r\n  offset2,\r\n  stride,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n) {\r\n  const x1 = flatCoordinates[offset1];\r\n  const y1 = flatCoordinates[offset1 + 1];\r\n  const dx = flatCoordinates[offset2] - x1;\r\n  const dy = flatCoordinates[offset2 + 1] - y1;\r\n  let offset;\r\n  if (dx === 0 && dy === 0) {\r\n    offset = offset1;\r\n  } else {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      offset = offset2;\r\n    } else if (t > 0) {\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = lerp(\r\n          flatCoordinates[offset1 + i],\r\n          flatCoordinates[offset2 + i],\r\n          t,\r\n        );\r\n      }\r\n      closestPoint.length = stride;\r\n      return;\r\n    } else {\r\n      offset = offset1;\r\n    }\r\n  }\r\n  for (let i = 0; i < stride; ++i) {\r\n    closestPoint[i] = flatCoordinates[offset + i];\r\n  }\r\n  closestPoint.length = stride;\r\n}\r\n\r\n/**\r\n * Return the squared of the largest distance between any pair of consecutive\r\n * coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\r\n    if (squaredDelta > max) {\r\n      max = squaredDelta;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function arrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\r\n    offset = end;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function multiArrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  if (offset == end) {\r\n    return minSquaredDistance;\r\n  }\r\n  let i, squaredDistance;\r\n  if (maxDelta === 0) {\r\n    // All points are identical, so just test the first point.\r\n    squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[offset],\r\n      flatCoordinates[offset + 1],\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[offset + i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  let index = offset + stride;\r\n  while (index < end) {\r\n    assignClosest(\r\n      flatCoordinates,\r\n      index - stride,\r\n      index,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      index += stride;\r\n    } else {\r\n      // Skip ahead multiple points, because we know that all the skipped\r\n      // points cannot be any closer than the closest point we have found so\r\n      // far.  We know this because we know how close the current point is, how\r\n      // close the closest point we have found so far is, and the maximum\r\n      // distance between consecutive points.  For example, if we're currently\r\n      // at distance 10, the best we've found so far is 3, and that the maximum\r\n      // distance between consecutive points is 2, then we'll need to skip at\r\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\r\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\r\n      // always advance at least one point, to avoid an infinite loop.\r\n      index +=\r\n        stride *\r\n        Math.max(\r\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\r\n            maxDelta) |\r\n            0,\r\n          1,\r\n        );\r\n    }\r\n  }\r\n  if (isRing) {\r\n    // Check the closing segment.\r\n    assignClosest(\r\n      flatCoordinates,\r\n      end - stride,\r\n      offset,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n    }\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    minSquaredDistance = assignClosestPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = end;\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestMultiArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    minSquaredDistance = assignClosestArrayPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/simplify\r\n */\r\n// Based on simplify-js https://github.com/mourner/simplify-js\r\n// Copyright (c) 2012, Vladimir Agafonkin\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//\r\n//    1. Redistributions of source code must retain the above copyright notice,\r\n//       this list of conditions and the following disclaimer.\r\n//\r\n//    2. Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {boolean} highQuality Highest quality.\r\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\r\n *     coordinates.\r\n * @return {Array<number>} Simplified line string.\r\n */\r\nexport function simplifyLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  highQuality,\r\n  simplifiedFlatCoordinates,\r\n) {\r\n  simplifiedFlatCoordinates =\r\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\r\n  if (!highQuality) {\r\n    end = radialDistance(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    flatCoordinates = simplifiedFlatCoordinates;\r\n    offset = 0;\r\n    stride = 2;\r\n  }\r\n  simplifiedFlatCoordinates.length = douglasPeucker(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    squaredTolerance,\r\n    simplifiedFlatCoordinates,\r\n    0,\r\n  );\r\n  return simplifiedFlatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeucker(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  const n = (end - offset) / stride;\r\n  if (n < 3) {\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  /** @type {Array<number>} */\r\n  const markers = new Array(n);\r\n  markers[0] = 1;\r\n  markers[n - 1] = 1;\r\n  /** @type {Array<number>} */\r\n  const stack = [offset, end - stride];\r\n  let index = 0;\r\n  while (stack.length > 0) {\r\n    const last = stack.pop();\r\n    const first = stack.pop();\r\n    let maxSquaredDistance = 0;\r\n    const x1 = flatCoordinates[first];\r\n    const y1 = flatCoordinates[first + 1];\r\n    const x2 = flatCoordinates[last];\r\n    const y2 = flatCoordinates[last + 1];\r\n    for (let i = first + stride; i < last; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\r\n      if (squaredDistance > maxSquaredDistance) {\r\n        index = i;\r\n        maxSquaredDistance = squaredDistance;\r\n      }\r\n    }\r\n    if (maxSquaredDistance > squaredTolerance) {\r\n      markers[(index - offset) / stride] = 1;\r\n      if (first + stride < index) {\r\n        stack.push(first, index);\r\n      }\r\n      if (index + stride < last) {\r\n        stack.push(index, last);\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < n; ++i) {\r\n    if (markers[i]) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride + 1];\r\n    }\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = douglasPeucker(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = douglasPeuckerArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function radialDistance(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  if (end <= offset + stride) {\r\n    // zero or one point, no simplification possible, so copy and return\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  // copy first point\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  let x2 = x1;\r\n  let y2 = y1;\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    x2 = flatCoordinates[offset];\r\n    y2 = flatCoordinates[offset + 1];\r\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\r\n      // copy point at offset\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  if (x2 != x1 || y2 != y1) {\r\n    // copy last point\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {number} value Value.\r\n * @param {number} tolerance Tolerance.\r\n * @return {number} Rounded value.\r\n */\r\nexport function snap(value, tolerance) {\r\n  return tolerance * Math.round(value / tolerance);\r\n}\r\n\r\n/**\r\n * Simplifies a line string using an algorithm designed by Tim Schaub.\r\n * Coordinates are snapped to the nearest value in a virtual grid and\r\n * consecutive duplicate coordinates are discarded.  This effectively preserves\r\n * topology as the simplification of any subsection of a line string is\r\n * independent of the rest of the line string.  This means that, for examples,\r\n * the common edge between two polygons will be simplified to the same line\r\n * string independently in both polygons.  This implementation uses a single\r\n * pass over the coordinates and eliminates intermediate collinear points.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantize(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  // do nothing if the line is empty\r\n  if (offset == end) {\r\n    return simplifiedOffset;\r\n  }\r\n  // snap the first coordinate (P1)\r\n  let x1 = snap(flatCoordinates[offset], tolerance);\r\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\r\n  offset += stride;\r\n  // add the first coordinate to the output\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  // find the next coordinate that does not snap to the same value as the first\r\n  // coordinate (P2)\r\n  let x2, y2;\r\n  do {\r\n    x2 = snap(flatCoordinates[offset], tolerance);\r\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    if (offset == end) {\r\n      // all coordinates snap to the same value, the line collapses to a point\r\n      // push the last snapped value anyway to ensure that the output contains\r\n      // at least two points\r\n      // FIXME should we really return at least two points anyway?\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      return simplifiedOffset;\r\n    }\r\n  } while (x2 == x1 && y2 == y1);\r\n  while (offset < end) {\r\n    // snap the next coordinate (P3)\r\n    const x3 = snap(flatCoordinates[offset], tolerance);\r\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    // skip P3 if it is equal to P2\r\n    if (x3 == x2 && y3 == y2) {\r\n      continue;\r\n    }\r\n    // calculate the delta between P1 and P2\r\n    const dx1 = x2 - x1;\r\n    const dy1 = y2 - y1;\r\n    // calculate the delta between P3 and P1\r\n    const dx2 = x3 - x1;\r\n    const dy2 = y3 - y1;\r\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\r\n    // P1 in the same direction then P2 is on the straight line between P1 and\r\n    // P3\r\n    if (\r\n      dx1 * dy2 == dy1 * dx2 &&\r\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\r\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\r\n    ) {\r\n      // discard P2 and set P2 = P3\r\n      x2 = x3;\r\n      y2 = y3;\r\n      continue;\r\n    }\r\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\r\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\r\n    // and continue with P1 = P2 and P2 = P3\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n    x1 = x2;\r\n    y1 = y2;\r\n    x2 = x3;\r\n    y2 = y3;\r\n  }\r\n  // add the last point (P2)\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = quantize(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = quantizeArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/area\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRing(flatCoordinates, offset, end, stride) {\r\n  let twiceArea = 0;\r\n  const x0 = flatCoordinates[end - stride];\r\n  const y0 = flatCoordinates[end - stride + 1];\r\n  let dx1 = 0;\r\n  let dy1 = 0;\r\n  for (; offset < end; offset += stride) {\r\n    const dx2 = flatCoordinates[offset] - x0;\r\n    const dy2 = flatCoordinates[offset + 1] - y0;\r\n    twiceArea += dy1 * dx2 - dx1 * dy2;\r\n    dx1 = dx2;\r\n    dy1 = dy2;\r\n  }\r\n  return twiceArea / 2;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRings(flatCoordinates, offset, ends, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    area += linearRing(flatCoordinates, offset, end, stride);\r\n    offset = end;\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    area += linearRings(flatCoordinates, offset, ends, stride);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return area;\r\n}\r\n", "/**\r\n * @module ol/geom/LinearRing\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateCoordinates} from './flat/deflate.js';\r\nimport {douglasPeucker} from './flat/simplify.js';\r\nimport {inflateCoordinates} from './flat/inflate.js';\r\nimport {linearRing as linearRingArea} from './flat/area.js';\r\n\r\n/**\r\n * @classdesc\r\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\r\n * on its own.\r\n *\r\n * @api\r\n */\r\nclass LinearRing extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!LinearRing} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        maxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.flatCoordinates.length,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the linear ring on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingArea(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the linear ring.\r\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LinearRing} Simplified LinearRing.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    simplifiedFlatCoordinates.length = douglasPeucker(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'LinearRing';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the linear ring.\r\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 1);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default LinearRing;\r\n", "/**\r\n * @module ol/geom/flat/interiorpoint\r\n */\r\nimport {ascending} from '../../array.js';\r\nimport {linearRingsContainsXY} from './contains.js';\r\n\r\n/**\r\n * Calculates a point that is likely to lie in the interior of the linear rings.\r\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @param {number} flatCentersOffset Flat center offset.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointOfArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  flatCenters,\r\n  flatCentersOffset,\r\n  dest,\r\n) {\r\n  let i, ii, x, x1, x2, y1, y2;\r\n  const y = flatCenters[flatCentersOffset + 1];\r\n  /** @type {Array<number>} */\r\n  const intersections = [];\r\n  // Calculate intersections with the horizontal line\r\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\r\n    const end = ends[r];\r\n    x1 = flatCoordinates[end - stride];\r\n    y1 = flatCoordinates[end - stride + 1];\r\n    for (i = offset; i < end; i += stride) {\r\n      x2 = flatCoordinates[i];\r\n      y2 = flatCoordinates[i + 1];\r\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\r\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\r\n        intersections.push(x);\r\n      }\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  // Find the longest segment of the horizontal line that has its center point\r\n  // inside the linear ring.\r\n  let pointX = NaN;\r\n  let maxSegmentLength = -Infinity;\r\n  intersections.sort(ascending);\r\n  x1 = intersections[0];\r\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\r\n    x2 = intersections[i];\r\n    const segmentLength = Math.abs(x2 - x1);\r\n    if (segmentLength > maxSegmentLength) {\r\n      x = (x1 + x2) / 2;\r\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\r\n        pointX = x;\r\n        maxSegmentLength = segmentLength;\r\n      }\r\n    }\r\n    x1 = x2;\r\n  }\r\n  if (isNaN(pointX)) {\r\n    // There is no horizontal line that has its center point inside the linear\r\n    // ring.  Use the center of the the linear ring's extent.\r\n    pointX = flatCenters[flatCentersOffset];\r\n  }\r\n  if (dest) {\r\n    dest.push(pointX, y, maxSegmentLength);\r\n    return dest;\r\n  }\r\n  return [pointX, y, maxSegmentLength];\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointsOfMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  flatCenters,\r\n) {\r\n  /** @type {Array<number>} */\r\n  let interiorPoints = [];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    interiorPoints = getInteriorPointOfArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      flatCenters,\r\n      2 * i,\r\n      interiorPoints,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return interiorPoints;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/reverse\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n */\r\nexport function coordinates(flatCoordinates, offset, end, stride) {\r\n  while (offset < end - stride) {\r\n    for (let i = 0; i < stride; ++i) {\r\n      const tmp = flatCoordinates[offset + i];\r\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\r\n      flatCoordinates[end - stride + i] = tmp;\r\n    }\r\n    offset += stride;\r\n    end -= stride;\r\n  }\r\n}\r\n", "/**\r\n * @module ol/geom/flat/orient\r\n */\r\nimport {coordinates as reverseCoordinates} from './reverse.js';\r\n\r\n/**\r\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\r\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\r\n * the ring's orientation is clockwise when this function returns false.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {boolean|undefined} Is clockwise.\r\n */\r\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\r\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\r\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\r\n  let edge = 0;\r\n  let x1 = flatCoordinates[end - stride];\r\n  let y1 = flatCoordinates[end - stride + 1];\r\n  for (; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    edge += (x2 - x1) * (y2 + y1);\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return edge === 0 ? undefined : edge > 0;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingsAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    if (i === 0) {\r\n      if ((right && isClockwise) || (!right && !isClockwise)) {\r\n        return false;\r\n      }\r\n    } else {\r\n      if ((right && !isClockwise) || (!right && isClockwise)) {\r\n        return false;\r\n      }\r\n    }\r\n    offset = end;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingssAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\r\n      return false;\r\n    }\r\n    if (ends.length) {\r\n      offset = ends[ends.length - 1];\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRings(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    const reverse =\r\n      i === 0\r\n        ? (right && isClockwise) || (!right && !isClockwise)\r\n        : (right && !isClockwise) || (!right && isClockwise);\r\n    if (reverse) {\r\n      reverseCoordinates(flatCoordinates, offset, end, stride);\r\n    }\r\n    offset = end;\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRingsArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    offset = orientLinearRings(\r\n      flatCoordinates,\r\n      offset,\r\n      endss[i],\r\n      stride,\r\n      right,\r\n    );\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Return a two-dimensional endss\r\n * @param {Array<number>} flatCoordinates Flat coordinates\r\n * @param {Array<number>} ends Linear ring end indexes\r\n * @return {Array<Array<number>>} Two dimensional endss array that can\r\n * be used to construct a MultiPolygon\r\n */\r\nexport function inflateEnds(flatCoordinates, ends) {\r\n  const endss = [];\r\n  let offset = 0;\r\n  let prevEndIndex = 0;\r\n  let startOrientation;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    // classifies an array of rings into polygons with outer rings and holes\r\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\r\n    if (startOrientation === undefined) {\r\n      startOrientation = orientation;\r\n    }\r\n    if (orientation === startOrientation) {\r\n      endss.push(ends.slice(prevEndIndex, i + 1));\r\n    } else {\r\n      if (endss.length === 0) {\r\n        continue;\r\n      }\r\n      endss[endss.length - 1].push(ends[prevEndIndex]);\r\n    }\r\n    prevEndIndex = i + 1;\r\n    offset = end;\r\n  }\r\n  return endss;\r\n}\r\n", "/**\r\n * @module ol/geom/Polygon\r\n */\r\nimport LinearRing from './LinearRing.js';\r\nimport Point from './Point.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\r\nimport {deflateCoordinatesArray} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\r\nimport {inflateCoordinatesArray} from './flat/inflate.js';\r\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\r\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\r\nimport {linearRings as linearRingsArea} from './flat/area.js';\r\nimport {linearRingsContainsXY} from './flat/contains.js';\r\nimport {modulo} from '../math.js';\r\nimport {quantizeArray} from './flat/simplify.js';\r\nimport {offset as sphereOffset} from '../sphere.js';\r\n\r\n/**\r\n * @classdesc\r\n * Polygon geometry.\r\n *\r\n * @api\r\n */\r\nclass Polygon extends SimpleGeometry {\r\n  /**\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\r\n   *     Array of linear rings that define the polygon. The first linear ring of the\r\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\r\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\r\n   *     an array of vertices' coordinates where the first coordinate and the last are\r\n   *     equivalent. (For internal use, flat coordinates in combination with\r\n   *     `layout` and `ends` are also accepted.)\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\r\n   */\r\n  constructor(coordinates, layout, ends) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.ends_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatInteriorPointRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.flatInteriorPoint_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.orientedRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.orientedFlatCoordinates_ = null;\r\n\r\n    if (layout !== undefined && ends) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n      this.ends_ = ends;\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed linear ring to this polygon.\r\n   * @param {LinearRing} linearRing Linear ring.\r\n   * @api\r\n   */\r\n  appendLinearRing(linearRing) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\r\n    } else {\r\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\r\n    }\r\n    this.ends_.push(this.flatCoordinates.length);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Polygon} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    const polygon = new Polygon(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      this.ends_.slice(),\r\n    );\r\n    polygon.applyProperties(this);\r\n    return polygon;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        arrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestArrayPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   * @override\r\n   */\r\n  containsXY(x, y) {\r\n    return linearRingsContainsXY(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the polygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingsArea(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates(right) {\r\n    let flatCoordinates;\r\n    if (right !== undefined) {\r\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\r\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\r\n    } else {\r\n      flatCoordinates = this.flatCoordinates;\r\n    }\r\n\r\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Ends.\r\n   */\r\n  getEnds() {\r\n    return this.ends_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Interior point.\r\n   */\r\n  getFlatInteriorPoint() {\r\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\r\n      const flatCenter = getCenter(this.getExtent());\r\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\r\n        this.getOrientedFlatCoordinates(),\r\n        0,\r\n        this.ends_,\r\n        this.stride,\r\n        flatCenter,\r\n        0,\r\n      );\r\n      this.flatInteriorPointRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {import(\"../coordinate.js\").Coordinate} */ (\r\n      this.flatInteriorPoint_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return an interior point of the polygon.\r\n   * @return {Point} Interior point as XYM coordinate, where M is the\r\n   * length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\r\n  getInteriorPoint() {\r\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\r\n  }\r\n\r\n  /**\r\n   * Return the number of rings of the polygon,  this includes the exterior\r\n   * ring and any interior rings.\r\n   *\r\n   * @return {number} Number of rings.\r\n   * @api\r\n   */\r\n  getLinearRingCount() {\r\n    return this.ends_.length;\r\n  }\r\n\r\n  /**\r\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\r\n   * given index is out of range.\r\n   * The exterior linear ring is available at index `0` and the interior rings\r\n   * at index `1` and beyond.\r\n   *\r\n   * @param {number} index Index.\r\n   * @return {LinearRing|null} Linear ring.\r\n   * @api\r\n   */\r\n  getLinearRing(index) {\r\n    if (index < 0 || this.ends_.length <= index) {\r\n      return null;\r\n    }\r\n    return new LinearRing(\r\n      this.flatCoordinates.slice(\r\n        index === 0 ? 0 : this.ends_[index - 1],\r\n        this.ends_[index],\r\n      ),\r\n      this.layout,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the linear rings of the polygon.\r\n   * @return {Array<LinearRing>} Linear rings.\r\n   * @api\r\n   */\r\n  getLinearRings() {\r\n    const layout = this.layout;\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const ends = this.ends_;\r\n    const linearRings = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n      const end = ends[i];\r\n      const linearRing = new LinearRing(\r\n        flatCoordinates.slice(offset, end),\r\n        layout,\r\n      );\r\n      linearRings.push(linearRing);\r\n      offset = end;\r\n    }\r\n    return linearRings;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\r\n  getOrientedFlatCoordinates() {\r\n    if (this.orientedRevision_ != this.getRevision()) {\r\n      const flatCoordinates = this.flatCoordinates;\r\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\r\n        this.orientedFlatCoordinates_ = flatCoordinates;\r\n      } else {\r\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\r\n        this.orientedFlatCoordinates_.length = orientLinearRings(\r\n          this.orientedFlatCoordinates_,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n        );\r\n      }\r\n      this.orientedRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {Polygon} Simplified Polygon.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedFlatCoordinates.length = quantizeArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      Math.sqrt(squaredTolerance),\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEnds,\r\n    );\r\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'Polygon';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLinearRingArray(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the polygon.\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 2);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const ends = deflateCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.ends_,\r\n    );\r\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default Polygon;\r\n\r\n/**\r\n * Create an approximation of a circle on the surface of a sphere.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\r\n * @param {number} radius The great-circle distance from the center to\r\n *     the polygon vertices in meters.\r\n * @param {number} [n] Optional number of vertices for the resulting\r\n *     polygon. Default is `32`.\r\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\r\n *     the Earth's mean radius using the WGS84 ellipsoid).\r\n * @return {Polygon} The \"circular\" polygon.\r\n * @api\r\n */\r\nexport function circular(center, radius, n, sphereRadius) {\r\n  n = n ? n : 32;\r\n  /** @type {Array<number>} */\r\n  const flatCoordinates = [];\r\n  for (let i = 0; i < n; ++i) {\r\n    extend(\r\n      flatCoordinates,\r\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius),\r\n    );\r\n  }\r\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a polygon from an extent. The layout used is `XY`.\r\n * @param {import(\"../extent.js\").Extent} extent The extent.\r\n * @return {Polygon} The polygon.\r\n * @api\r\n */\r\nexport function fromExtent(extent) {\r\n  if (isEmpty(extent)) {\r\n    throw new Error('Cannot create polygon from empty extent');\r\n  }\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const flatCoordinates = [\r\n    minX,\r\n    minY,\r\n    minX,\r\n    maxY,\r\n    maxX,\r\n    maxY,\r\n    maxX,\r\n    minY,\r\n    minX,\r\n    minY,\r\n  ];\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a regular polygon from a circle.\r\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\r\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n * @return {Polygon} Polygon geometry.\r\n * @api\r\n */\r\nexport function fromCircle(circle, sides, angle) {\r\n  sides = sides ? sides : 32;\r\n  const stride = circle.getStride();\r\n  const layout = circle.getLayout();\r\n  const center = circle.getCenter();\r\n  const arrayLength = stride * (sides + 1);\r\n  const flatCoordinates = new Array(arrayLength);\r\n  for (let i = 0; i < arrayLength; i += stride) {\r\n    flatCoordinates[i] = 0;\r\n    flatCoordinates[i + 1] = 0;\r\n    for (let j = 2; j < stride; j++) {\r\n      flatCoordinates[i + j] = center[j];\r\n    }\r\n  }\r\n  const ends = [flatCoordinates.length];\r\n  const polygon = new Polygon(flatCoordinates, layout, ends);\r\n  makeRegular(polygon, center, circle.getRadius(), angle);\r\n  return polygon;\r\n}\r\n\r\n/**\r\n * Modify the coordinates of a polygon to make it a regular polygon.\r\n * @param {Polygon} polygon Polygon geometry.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\r\n * @param {number} radius Radius of the regular polygon.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n */\r\nexport function makeRegular(polygon, center, radius, angle) {\r\n  const flatCoordinates = polygon.getFlatCoordinates();\r\n  const stride = polygon.getStride();\r\n  const sides = flatCoordinates.length / stride - 1;\r\n  const startAngle = angle ? angle : 0;\r\n  for (let i = 0; i <= sides; ++i) {\r\n    const offset = i * stride;\r\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\r\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\r\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\r\n  }\r\n  polygon.changed();\r\n}\r\n"],
  "mappings": "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",
  "names": ["offset", "coordinates", "offset", "squaredDistance", "offset", "squaredDistance", "offset", "offset", "coordinates", "offset", "offset", "offset", "coordinates", "linearRing", "linearRings", "offset", "angle"]
}
