{
  "version": 3,
  "sources": ["../../ol/interaction/Modify.js"],
  "sourcesContent": ["/**\r\n * @module ol/interaction/Modify\r\n */\r\nimport Collection from '../Collection.js';\r\nimport CollectionEventType from '../CollectionEventType.js';\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport Feature from '../Feature.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport Point from '../geom/Point.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport RBush from '../structs/RBush.js';\r\nimport VectorEventType from '../source/VectorEventType.js';\r\nimport VectorLayer from '../layer/Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {\r\n  altKeyOnly,\r\n  always,\r\n  primaryAction,\r\n  singleClick,\r\n} from '../events/condition.js';\r\nimport {\r\n  boundingExtent,\r\n  buffer as bufferExtent,\r\n  createOrUpdateFromCoordinate as createExtent,\r\n} from '../extent.js';\r\nimport {\r\n  closestOnSegment,\r\n  distance as coordinateDistance,\r\n  equals as coordinatesEqual,\r\n  squaredDistance as squaredCoordinateDistance,\r\n  squaredDistanceToSegment,\r\n} from '../coordinate.js';\r\nimport {createEditingStyle} from '../style/Style.js';\r\nimport {equals} from '../array.js';\r\nimport {fromCircle} from '../geom/Polygon.js';\r\nimport {\r\n  fromUserCoordinate,\r\n  fromUserExtent,\r\n  getUserProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from '../proj.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * The segment index assigned to a circle's center when\r\n * breaking up a circle into ModifySegmentDataType segments.\r\n * @type {number}\r\n */\r\nconst CIRCLE_CENTER_INDEX = 0;\r\n\r\n/**\r\n * The segment index assigned to a circle's circumference when\r\n * breaking up a circle into ModifySegmentDataType segments.\r\n * @type {number}\r\n */\r\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\r\n\r\nconst tempExtent = [0, 0, 0, 0];\r\nconst tempSegment = [];\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst ModifyEventType = {\r\n  /**\r\n   * Triggered upon feature modification start\r\n   * @event ModifyEvent#modifystart\r\n   * @api\r\n   */\r\n  MODIFYSTART: 'modifystart',\r\n  /**\r\n   * Triggered upon feature modification end\r\n   * @event ModifyEvent#modifyend\r\n   * @api\r\n   */\r\n  MODIFYEND: 'modifyend',\r\n};\r\n\r\n/**\r\n * @typedef {Object} SegmentData\r\n * @property {Array<number>} [depth] Depth.\r\n * @property {Feature} feature Feature.\r\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n * @property {number} [index] Index.\r\n * @property {Array<Array<number>>} segment Segment.\r\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event will be considered to add or move a\r\n * vertex to the sketch. Default is\r\n * {@link module:ol/events/condition.primaryAction}.\r\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\r\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. By default,\r\n * {@link module:ol/events/condition.singleClick} with\r\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\r\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\r\n * function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\r\n * returns a boolean to indicate whether a new vertex should be added to the sketch\r\n * features. Default is {@link module:ol/events/condition.always}.\r\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\r\n * pointer close enough to a segment or vertex for editing.\r\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\r\n * Style used for the modification point or vertex. For linestrings and polygons, this will\r\n * be the affected vertex, for circles a point along the circle, and for points the actual\r\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\r\n * When using a style function, the point feature passed to the function will have a `features`\r\n * property - an array whose entries are the features that are being modified, and a `geometries`\r\n * property - an array whose entries are the geometries that are being modified. Both arrays are\r\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\r\n * the geometry will be the particular geometry from the collection that is being modified.\r\n * @property {VectorSource} [source] The vector source with\r\n * features to modify.  If a vector source is not provided, a feature collection\r\n * must be provided with the `features` option.\r\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\r\n * features will be considered for modification based on their visual appearance, instead of being within\r\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\r\n * provided, only the rendered representation of the features on that layer will be considered.\r\n * @property {Collection<Feature>} [features]\r\n * The features the interaction works on.  If a feature collection is not\r\n * provided, a vector source must be provided with the `source` option.\r\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\r\n * overlay.\r\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\r\n * pointer coordinate when clicked within the `pixelTolerance`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\r\n * instances of this type.\r\n */\r\nexport class ModifyEvent extends Event {\r\n  /**\r\n   * @param {ModifyEventType} type Type.\r\n   * @param {Collection<Feature>} features\r\n   * The features modified.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\r\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n   */\r\n  constructor(type, features, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features being modified.\r\n     * @type {Collection<Feature>}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for modifying feature geometries.  To modify features that have\r\n * been added to an existing source, construct the modify interaction with the\r\n * `source` option.  If you want to modify features in a collection (for example,\r\n * the collection used by a select interaction), construct the interaction with\r\n * the `features` option.  The interaction must be constructed with either a\r\n * `source` or `features` option.\r\n *\r\n * Cartesian distance from the pointer is used to determine the features that\r\n * will be modified. This means that geometries will only be considered for\r\n * modification when they are within the configured `pixelTolerance`. For point\r\n * geometries, the `hitDetection` option can be used to match their visual\r\n * appearance.\r\n *\r\n * By default, the interaction will allow deletion of vertices when the `alt`\r\n * key is pressed.  To configure the interaction with a different condition\r\n * for deletion, use the `deleteCondition` option.\r\n * @fires ModifyEvent\r\n * @api\r\n */\r\nclass Modify extends PointerInteraction {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ModifyOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /** @private */\r\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : primaryAction;\r\n\r\n    /**\r\n     * @private\r\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\r\n     * @return {boolean} Combined condition result.\r\n     */\r\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\r\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.deleteCondition_ = options.deleteCondition\r\n      ? options.deleteCondition\r\n      : this.defaultDeleteCondition_;\r\n\r\n    /**\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     * @private\r\n     */\r\n    this.insertVertexCondition_ = options.insertVertexCondition\r\n      ? options.insertVertexCondition\r\n      : always;\r\n\r\n    /**\r\n     * Editing vertex.\r\n     * @type {Feature<Point>}\r\n     * @private\r\n     */\r\n    this.vertexFeature_ = null;\r\n\r\n    /**\r\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\r\n     * @type {Object<string, boolean>}\r\n     * @private\r\n     */\r\n    this.vertexSegments_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     * @private\r\n     */\r\n    this.lastPixel_ = [0, 0];\r\n\r\n    /**\r\n     * Tracks if the next `singleclick` event should be ignored to prevent\r\n     * accidental deletion right after vertex creation.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.ignoreNextSingleClick_ = false;\r\n\r\n    /**\r\n     * @type {Collection<Feature>}\r\n     * @private\r\n     */\r\n    this.featuresBeingModified_ = null;\r\n\r\n    /**\r\n     * Segment RTree for each layer\r\n     * @type {RBush<SegmentData>}\r\n     * @private\r\n     */\r\n    this.rBush_ = new RBush();\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.pixelTolerance_ =\r\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.snappedToVertex_ = false;\r\n\r\n    /**\r\n     * Indicate whether the interaction is currently changing a feature's\r\n     * coordinates.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.changingFeature_ = false;\r\n\r\n    /**\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    this.dragSegments_ = [];\r\n\r\n    /**\r\n     * Draw overlay where sketch features are drawn.\r\n     * @type {VectorLayer}\r\n     * @private\r\n     */\r\n    this.overlay_ = new VectorLayer({\r\n      source: new VectorSource({\r\n        useSpatialIndex: false,\r\n        wrapX: !!options.wrapX,\r\n      }),\r\n      style: options.style ? options.style : getDefaultStyleFunction(),\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    });\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\r\n     */\r\n    this.SEGMENT_WRITERS_ = {\r\n      'Point': this.writePointGeometry_.bind(this),\r\n      'LineString': this.writeLineStringGeometry_.bind(this),\r\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\r\n      'Polygon': this.writePolygonGeometry_.bind(this),\r\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\r\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\r\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\r\n      'Circle': this.writeCircleGeometry_.bind(this),\r\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\r\n    };\r\n\r\n    /**\r\n     * @type {VectorSource}\r\n     * @private\r\n     */\r\n    this.source_ = null;\r\n\r\n    /**\r\n     * @type {boolean|import(\"../layer/BaseVector\").default}\r\n     * @private\r\n     */\r\n    this.hitDetection_ = null;\r\n\r\n    /** @type {Collection<Feature>} */\r\n    let features;\r\n    if (options.features) {\r\n      features = options.features;\r\n    } else if (options.source) {\r\n      this.source_ = options.source;\r\n      features = new Collection(this.source_.getFeatures());\r\n      this.source_.addEventListener(\r\n        VectorEventType.ADDFEATURE,\r\n        this.handleSourceAdd_.bind(this),\r\n      );\r\n      this.source_.addEventListener(\r\n        VectorEventType.REMOVEFEATURE,\r\n        this.handleSourceRemove_.bind(this),\r\n      );\r\n    }\r\n    if (!features) {\r\n      throw new Error(\r\n        'The modify interaction requires features, a source or a layer',\r\n      );\r\n    }\r\n    if (options.hitDetection) {\r\n      this.hitDetection_ = options.hitDetection;\r\n    }\r\n\r\n    /**\r\n     * @type {Collection<Feature>}\r\n     * @private\r\n     */\r\n    this.features_ = features;\r\n\r\n    this.features_.forEach(this.addFeature_.bind(this));\r\n    this.features_.addEventListener(\r\n      CollectionEventType.ADD,\r\n      this.handleFeatureAdd_.bind(this),\r\n    );\r\n    this.features_.addEventListener(\r\n      CollectionEventType.REMOVE,\r\n      this.handleFeatureRemove_.bind(this),\r\n    );\r\n\r\n    /**\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @private\r\n     */\r\n    this.lastPointerEvent_ = null;\r\n\r\n    /**\r\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.delta_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.snapToPointer_ =\r\n      options.snapToPointer === undefined\r\n        ? !this.hitDetection_\r\n        : options.snapToPointer;\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  addFeature_(feature) {\r\n    const geometry = feature.getGeometry();\r\n    if (geometry) {\r\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\r\n      if (writer) {\r\n        writer(feature, geometry);\r\n      }\r\n    }\r\n    const map = this.getMap();\r\n    if (map && map.isRendered() && this.getActive()) {\r\n      this.handlePointerAtPixel_(this.lastPixel_, map);\r\n    }\r\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\r\n   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.\r\n   * @private\r\n   */\r\n  willModifyFeatures_(evt, segments) {\r\n    if (!this.featuresBeingModified_) {\r\n      this.featuresBeingModified_ = new Collection();\r\n      const features = this.featuresBeingModified_.getArray();\r\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\r\n        const segment = segments[i];\r\n        for (let s = 0, ss = segment.length; s < ss; ++s) {\r\n          const feature = segment[s].feature;\r\n          if (feature && !features.includes(feature)) {\r\n            this.featuresBeingModified_.push(feature);\r\n          }\r\n        }\r\n      }\r\n      if (this.featuresBeingModified_.getLength() === 0) {\r\n        this.featuresBeingModified_ = null;\r\n      } else {\r\n        this.dispatchEvent(\r\n          new ModifyEvent(\r\n            ModifyEventType.MODIFYSTART,\r\n            this.featuresBeingModified_,\r\n            evt,\r\n          ),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  removeFeature_(feature) {\r\n    this.removeFeatureSegmentData_(feature);\r\n    // Remove the vertex feature if the collection of candidate features is empty.\r\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n    feature.removeEventListener(\r\n      EventType.CHANGE,\r\n      this.boundHandleFeatureChange_,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature.\r\n   * @private\r\n   */\r\n  removeFeatureSegmentData_(feature) {\r\n    const rBush = this.rBush_;\r\n    /** @type {Array<SegmentData>} */\r\n    const nodesToRemove = [];\r\n    rBush.forEach(\r\n      /**\r\n       * @param {SegmentData} node RTree node.\r\n       */\r\n      function (node) {\r\n        if (feature === node.feature) {\r\n          nodesToRemove.push(node);\r\n        }\r\n      },\r\n    );\r\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\r\n      const nodeToRemove = nodesToRemove[i];\r\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\r\n        if (this.dragSegments_[j][0] === nodeToRemove) {\r\n          this.dragSegments_.splice(j, 1);\r\n        }\r\n      }\r\n      rBush.remove(nodeToRemove);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   * @override\r\n   */\r\n  setActive(active) {\r\n    if (this.vertexFeature_ && !active) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n    super.setActive(active);\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @override\r\n   */\r\n  setMap(map) {\r\n    this.overlay_.setMap(map);\r\n    super.setMap(map);\r\n  }\r\n\r\n  /**\r\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\r\n   * @return {VectorLayer} Overlay layer.\r\n   * @api\r\n   */\r\n  getOverlay() {\r\n    return this.overlay_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\r\n   * @private\r\n   */\r\n  handleSourceAdd_(event) {\r\n    if (event.feature) {\r\n      this.features_.push(event.feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\r\n   * @private\r\n   */\r\n  handleSourceRemove_(event) {\r\n    if (event.feature) {\r\n      this.features_.remove(event.feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureAdd_(evt) {\r\n    this.addFeature_(evt.element);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../events/Event.js\").default} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureChange_(evt) {\r\n    if (!this.changingFeature_) {\r\n      const feature = /** @type {Feature} */ (evt.target);\r\n      this.removeFeature_(feature);\r\n      this.addFeature_(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\r\n   * @private\r\n   */\r\n  handleFeatureRemove_(evt) {\r\n    this.removeFeature_(evt.element);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {Point} geometry Geometry.\r\n   * @private\r\n   */\r\n  writePointGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCoordinates();\r\n\r\n    /** @type {SegmentData} */\r\n    const segmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    this.rBush_.insert(geometry.getExtent(), segmentData);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiPointGeometry_(feature, geometry) {\r\n    const points = geometry.getCoordinates();\r\n    for (let i = 0, ii = points.length; i < ii; ++i) {\r\n      const coordinates = points[i];\r\n\r\n      /** @type {SegmentData} */\r\n      const segmentData = {\r\n        feature: feature,\r\n        geometry: geometry,\r\n        depth: [i],\r\n        index: i,\r\n        segment: [coordinates, coordinates],\r\n      };\r\n\r\n      this.rBush_.insert(geometry.getExtent(), segmentData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeLineStringGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCoordinates();\r\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n      const segment = coordinates.slice(i, i + 2);\r\n\r\n      /** @type {SegmentData} */\r\n      const segmentData = {\r\n        feature: feature,\r\n        geometry: geometry,\r\n        index: i,\r\n        segment: segment,\r\n      };\r\n\r\n      this.rBush_.insert(boundingExtent(segment), segmentData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiLineStringGeometry_(feature, geometry) {\r\n    const lines = geometry.getCoordinates();\r\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\r\n      const coordinates = lines[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        const segment = coordinates.slice(i, i + 2);\r\n\r\n        /** @type {SegmentData} */\r\n        const segmentData = {\r\n          feature: feature,\r\n          geometry: geometry,\r\n          depth: [j],\r\n          index: i,\r\n          segment: segment,\r\n        };\r\n\r\n        this.rBush_.insert(boundingExtent(segment), segmentData);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writePolygonGeometry_(feature, geometry) {\r\n    const rings = geometry.getCoordinates();\r\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n      const coordinates = rings[j];\r\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n        const segment = coordinates.slice(i, i + 2);\r\n\r\n        /** @type {SegmentData} */\r\n        const segmentData = {\r\n          feature: feature,\r\n          geometry: geometry,\r\n          depth: [j],\r\n          index: i,\r\n          segment: segment,\r\n        };\r\n\r\n        this.rBush_.insert(boundingExtent(segment), segmentData);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeMultiPolygonGeometry_(feature, geometry) {\r\n    const polygons = geometry.getCoordinates();\r\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\r\n      const rings = polygons[k];\r\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\r\n        const coordinates = rings[j];\r\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\r\n          const segment = coordinates.slice(i, i + 2);\r\n\r\n          /** @type {SegmentData} */\r\n          const segmentData = {\r\n            feature: feature,\r\n            geometry: geometry,\r\n            depth: [j, k],\r\n            index: i,\r\n            segment: segment,\r\n          };\r\n\r\n          this.rBush_.insert(boundingExtent(segment), segmentData);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * We convert a circle into two segments.  The segment at index\r\n   * {@link CIRCLE_CENTER_INDEX} is the\r\n   * circle's center (a point).  The segment at index\r\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\r\n   * the circumference, and is not a line segment.\r\n   *\r\n   * @param {Feature} feature Feature.\r\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeCircleGeometry_(feature, geometry) {\r\n    const coordinates = geometry.getCenter();\r\n\r\n    /** @type {SegmentData} */\r\n    const centerSegmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      index: CIRCLE_CENTER_INDEX,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    /** @type {SegmentData} */\r\n    const circumferenceSegmentData = {\r\n      feature: feature,\r\n      geometry: geometry,\r\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\r\n      segment: [coordinates, coordinates],\r\n    };\r\n\r\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\r\n    centerSegmentData.featureSegments = featureSegments;\r\n    circumferenceSegmentData.featureSegments = featureSegments;\r\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\r\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\r\n      geometry\r\n    );\r\n    const userProjection = getUserProjection();\r\n    if (userProjection && this.getMap()) {\r\n      const projection = this.getMap().getView().getProjection();\r\n      circleGeometry = circleGeometry\r\n        .clone()\r\n        .transform(userProjection, projection);\r\n      circleGeometry = fromCircle(\r\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\r\n      ).transform(projection, userProjection);\r\n    }\r\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\r\n  }\r\n\r\n  /**\r\n   * @param {Feature} feature Feature\r\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\r\n   * @private\r\n   */\r\n  writeGeometryCollectionGeometry_(feature, geometry) {\r\n    const geometries = geometry.getGeometriesArray();\r\n    for (let i = 0; i < geometries.length; ++i) {\r\n      const geometry = geometries[i];\r\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\r\n      writer(feature, geometry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\r\n   * @param {Array<Feature>} features The features being modified.\r\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\r\n   * @return {Feature} Vertex feature.\r\n   * @private\r\n   */\r\n  createOrUpdateVertexFeature_(coordinates, features, geometries) {\r\n    let vertexFeature = this.vertexFeature_;\r\n    if (!vertexFeature) {\r\n      vertexFeature = new Feature(new Point(coordinates));\r\n      this.vertexFeature_ = vertexFeature;\r\n      this.overlay_.getSource().addFeature(vertexFeature);\r\n    } else {\r\n      const geometry = vertexFeature.getGeometry();\r\n      geometry.setCoordinates(coordinates);\r\n    }\r\n    vertexFeature.set('features', features);\r\n    vertexFeature.set('geometries', geometries);\r\n    return vertexFeature;\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @override\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!mapBrowserEvent.originalEvent) {\r\n      return true;\r\n    }\r\n    this.lastPointerEvent_ = mapBrowserEvent;\r\n\r\n    let handled;\r\n    if (\r\n      !mapBrowserEvent.map.getView().getInteracting() &&\r\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\r\n      !this.handlingDownUpSequence\r\n    ) {\r\n      this.handlePointerMove_(mapBrowserEvent);\r\n    }\r\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\r\n      if (\r\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\r\n        !this.ignoreNextSingleClick_\r\n      ) {\r\n        handled = this.removePoint();\r\n      } else {\r\n        handled = true;\r\n      }\r\n    }\r\n\r\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\r\n      this.ignoreNextSingleClick_ = false;\r\n    }\r\n\r\n    return super.handleEvent(mapBrowserEvent) && !handled;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @override\r\n   */\r\n  handleDragEvent(evt) {\r\n    this.ignoreNextSingleClick_ = false;\r\n    this.willModifyFeatures_(evt, this.dragSegments_);\r\n\r\n    const vertex = [\r\n      evt.coordinate[0] + this.delta_[0],\r\n      evt.coordinate[1] + this.delta_[1],\r\n    ];\r\n    const features = [];\r\n    const geometries = [];\r\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\r\n      const dragSegment = this.dragSegments_[i];\r\n      const segmentData = dragSegment[0];\r\n      const feature = segmentData.feature;\r\n      if (!features.includes(feature)) {\r\n        features.push(feature);\r\n      }\r\n      const geometry = segmentData.geometry;\r\n      if (!geometries.includes(geometry)) {\r\n        geometries.push(geometry);\r\n      }\r\n      const depth = segmentData.depth;\r\n      let coordinates;\r\n      const segment = segmentData.segment;\r\n      const index = dragSegment[1];\r\n\r\n      while (vertex.length < geometry.getStride()) {\r\n        vertex.push(segment[index][vertex.length]);\r\n      }\r\n\r\n      switch (geometry.getType()) {\r\n        case 'Point':\r\n          coordinates = vertex;\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          break;\r\n        case 'MultiPoint':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[segmentData.index] = vertex;\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          break;\r\n        case 'LineString':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'MultiLineString':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'Polygon':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'MultiPolygon':\r\n          coordinates = geometry.getCoordinates();\r\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\r\n          segment[index] = vertex;\r\n          break;\r\n        case 'Circle':\r\n          segment[0] = vertex;\r\n          segment[1] = vertex;\r\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\r\n            this.changingFeature_ = true;\r\n            geometry.setCenter(vertex);\r\n            this.changingFeature_ = false;\r\n          } else {\r\n            // We're dragging the circle's circumference:\r\n            this.changingFeature_ = true;\r\n            const projection = evt.map.getView().getProjection();\r\n            let radius = coordinateDistance(\r\n              fromUserCoordinate(geometry.getCenter(), projection),\r\n              fromUserCoordinate(vertex, projection),\r\n            );\r\n            const userProjection = getUserProjection();\r\n            if (userProjection) {\r\n              const circleGeometry = geometry\r\n                .clone()\r\n                .transform(userProjection, projection);\r\n              circleGeometry.setRadius(radius);\r\n              radius = circleGeometry\r\n                .transform(projection, userProjection)\r\n                .getRadius();\r\n            }\r\n            geometry.setRadius(radius);\r\n            this.changingFeature_ = false;\r\n          }\r\n          break;\r\n        default:\r\n        // pass\r\n      }\r\n\r\n      if (coordinates) {\r\n        this.setGeometryCoordinates_(geometry, coordinates);\r\n      }\r\n    }\r\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.condition_(evt)) {\r\n      return false;\r\n    }\r\n    const pixelCoordinate = evt.coordinate;\r\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\r\n    this.dragSegments_.length = 0;\r\n    this.featuresBeingModified_ = null;\r\n    const vertexFeature = this.vertexFeature_;\r\n    if (vertexFeature) {\r\n      const projection = evt.map.getView().getProjection();\r\n      const insertVertices = [];\r\n      const vertex = vertexFeature.getGeometry().getCoordinates();\r\n      const vertexExtent = boundingExtent([vertex]);\r\n      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\r\n      const componentSegments = {};\r\n      segmentDataMatches.sort(compareIndexes);\r\n      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\r\n        const segmentDataMatch = segmentDataMatches[i];\r\n        const segment = segmentDataMatch.segment;\r\n        let uid = getUid(segmentDataMatch.geometry);\r\n        const depth = segmentDataMatch.depth;\r\n        if (depth) {\r\n          uid += '-' + depth.join('-'); // separate feature components\r\n        }\r\n        if (!componentSegments[uid]) {\r\n          componentSegments[uid] = new Array(2);\r\n        }\r\n\r\n        if (\r\n          segmentDataMatch.geometry.getType() === 'Circle' &&\r\n          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n        ) {\r\n          const closestVertex = closestOnSegmentData(\r\n            pixelCoordinate,\r\n            segmentDataMatch,\r\n            projection,\r\n          );\r\n          if (\r\n            coordinatesEqual(closestVertex, vertex) &&\r\n            !componentSegments[uid][0]\r\n          ) {\r\n            this.dragSegments_.push([segmentDataMatch, 0]);\r\n            componentSegments[uid][0] = segmentDataMatch;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          coordinatesEqual(segment[0], vertex) &&\r\n          !componentSegments[uid][0]\r\n        ) {\r\n          this.dragSegments_.push([segmentDataMatch, 0]);\r\n          componentSegments[uid][0] = segmentDataMatch;\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          coordinatesEqual(segment[1], vertex) &&\r\n          !componentSegments[uid][1]\r\n        ) {\r\n          if (\r\n            componentSegments[uid][0] &&\r\n            componentSegments[uid][0].index === 0\r\n          ) {\r\n            let coordinates = segmentDataMatch.geometry.getCoordinates();\r\n            switch (segmentDataMatch.geometry.getType()) {\r\n              // prevent dragging closed linestrings by the connecting node\r\n              case 'LineString':\r\n              case 'MultiLineString':\r\n                continue;\r\n              // if dragging the first vertex of a polygon, ensure the other segment\r\n              // belongs to the closing vertex of the linear ring\r\n              case 'MultiPolygon':\r\n                coordinates = coordinates[depth[1]];\r\n              /* falls through */\r\n              case 'Polygon':\r\n                if (\r\n                  segmentDataMatch.index !==\r\n                  coordinates[depth[0]].length - 2\r\n                ) {\r\n                  continue;\r\n                }\r\n                break;\r\n              default:\r\n              // pass\r\n            }\r\n          }\r\n\r\n          this.dragSegments_.push([segmentDataMatch, 1]);\r\n          componentSegments[uid][1] = segmentDataMatch;\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          getUid(segment) in this.vertexSegments_ &&\r\n          !componentSegments[uid][0] &&\r\n          !componentSegments[uid][1] &&\r\n          this.insertVertexCondition_(evt)\r\n        ) {\r\n          insertVertices.push(segmentDataMatch);\r\n        }\r\n      }\r\n\r\n      if (insertVertices.length) {\r\n        this.willModifyFeatures_(evt, [insertVertices]);\r\n      }\r\n\r\n      for (let j = insertVertices.length - 1; j >= 0; --j) {\r\n        this.insertVertex_(insertVertices[j], vertex);\r\n      }\r\n    }\r\n    return !!this.vertexFeature_;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\r\n  handleUpEvent(evt) {\r\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\r\n      const segmentData = this.dragSegments_[i][0];\r\n      const geometry = segmentData.geometry;\r\n      if (geometry.getType() === 'Circle') {\r\n        // Update a circle object in the R* bush:\r\n        const coordinates = geometry.getCenter();\r\n        const centerSegmentData = segmentData.featureSegments[0];\r\n        const circumferenceSegmentData = segmentData.featureSegments[1];\r\n        centerSegmentData.segment[0] = coordinates;\r\n        centerSegmentData.segment[1] = coordinates;\r\n        circumferenceSegmentData.segment[0] = coordinates;\r\n        circumferenceSegmentData.segment[1] = coordinates;\r\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\r\n        let circleGeometry = geometry;\r\n        const userProjection = getUserProjection();\r\n        if (userProjection) {\r\n          const projection = evt.map.getView().getProjection();\r\n          circleGeometry = circleGeometry\r\n            .clone()\r\n            .transform(userProjection, projection);\r\n          circleGeometry = fromCircle(circleGeometry).transform(\r\n            projection,\r\n            userProjection,\r\n          );\r\n        }\r\n        this.rBush_.update(\r\n          circleGeometry.getExtent(),\r\n          circumferenceSegmentData,\r\n        );\r\n      } else {\r\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\r\n      }\r\n    }\r\n    if (this.featuresBeingModified_) {\r\n      this.dispatchEvent(\r\n        new ModifyEvent(\r\n          ModifyEventType.MODIFYEND,\r\n          this.featuresBeingModified_,\r\n          evt,\r\n        ),\r\n      );\r\n      this.featuresBeingModified_ = null;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\r\n   * @private\r\n   */\r\n  handlePointerMove_(evt) {\r\n    this.lastPixel_ = evt.pixel;\r\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   * @param {import(\"../coordinate.js\").Coordinate} [coordinate] The pixel Coordinate.\r\n   * @private\r\n   */\r\n  handlePointerAtPixel_(pixel, map, coordinate) {\r\n    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);\r\n    const projection = map.getView().getProjection();\r\n    const sortByDistance = function (a, b) {\r\n      return (\r\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\r\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\r\n      );\r\n    };\r\n\r\n    /** @type {Array<SegmentData>|undefined} */\r\n    let nodes;\r\n    /** @type {Point|undefined} */\r\n    let hitPointGeometry;\r\n    if (this.hitDetection_) {\r\n      const layerFilter =\r\n        typeof this.hitDetection_ === 'object'\r\n          ? (layer) => layer === this.hitDetection_\r\n          : undefined;\r\n      map.forEachFeatureAtPixel(\r\n        pixel,\r\n        (feature, layer, geometry) => {\r\n          if (geometry && geometry.getType() === 'Point') {\r\n            geometry = new Point(\r\n              toUserCoordinate(geometry.getCoordinates(), projection),\r\n            );\r\n          }\r\n          const geom = geometry || feature.getGeometry();\r\n          if (\r\n            feature instanceof Feature &&\r\n            this.features_.getArray().includes(feature)\r\n          ) {\r\n            hitPointGeometry = /** @type {Point} */ (geom);\r\n            const coordinate = /** @type {Point} */ (feature.getGeometry())\r\n              .getFlatCoordinates()\r\n              .slice(0, 2);\r\n            nodes = [\r\n              {\r\n                feature,\r\n                geometry: hitPointGeometry,\r\n                segment: [coordinate, coordinate],\r\n              },\r\n            ];\r\n          }\r\n          return true;\r\n        },\r\n        {layerFilter},\r\n      );\r\n    }\r\n    if (!nodes) {\r\n      const viewExtent = fromUserExtent(\r\n        createExtent(pixelCoordinate, tempExtent),\r\n        projection,\r\n      );\r\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\r\n      const box = toUserExtent(\r\n        bufferExtent(viewExtent, buffer, tempExtent),\r\n        projection,\r\n      );\r\n      nodes = this.rBush_.getInExtent(box);\r\n    }\r\n\r\n    if (nodes && nodes.length > 0) {\r\n      const node = nodes.sort(sortByDistance)[0];\r\n      const closestSegment = node.segment;\r\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\r\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\r\n      let dist = coordinateDistance(pixel, vertexPixel);\r\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\r\n        /** @type {Object<string, boolean>} */\r\n        const vertexSegments = {};\r\n        vertexSegments[getUid(closestSegment)] = true;\r\n\r\n        if (!this.snapToPointer_) {\r\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\r\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\r\n        }\r\n        if (\r\n          node.geometry.getType() === 'Circle' &&\r\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n        ) {\r\n          this.snappedToVertex_ = true;\r\n          this.createOrUpdateVertexFeature_(\r\n            vertex,\r\n            [node.feature],\r\n            [node.geometry],\r\n          );\r\n        } else {\r\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\r\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\r\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\r\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\r\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\r\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\r\n          if (this.snappedToVertex_) {\r\n            vertex =\r\n              squaredDist1 > squaredDist2\r\n                ? closestSegment[1]\r\n                : closestSegment[0];\r\n          }\r\n          this.createOrUpdateVertexFeature_(\r\n            vertex,\r\n            [node.feature],\r\n            [node.geometry],\r\n          );\r\n          const geometries = {};\r\n          geometries[getUid(node.geometry)] = true;\r\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\r\n            const segment = nodes[i].segment;\r\n            if (\r\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\r\n                coordinatesEqual(closestSegment[1], segment[1])) ||\r\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\r\n                coordinatesEqual(closestSegment[1], segment[0]))\r\n            ) {\r\n              const geometryUid = getUid(nodes[i].geometry);\r\n              if (!(geometryUid in geometries)) {\r\n                geometries[geometryUid] = true;\r\n                vertexSegments[getUid(segment)] = true;\r\n              }\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        this.vertexSegments_ = vertexSegments;\r\n        return;\r\n      }\r\n    }\r\n    if (this.vertexFeature_) {\r\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n      this.vertexFeature_ = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {SegmentData} segmentData Segment data.\r\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\r\n   * @private\r\n   */\r\n  insertVertex_(segmentData, vertex) {\r\n    const segment = segmentData.segment;\r\n    const feature = segmentData.feature;\r\n    const geometry = segmentData.geometry;\r\n    const depth = segmentData.depth;\r\n    const index = segmentData.index;\r\n    let coordinates;\r\n\r\n    while (vertex.length < geometry.getStride()) {\r\n      vertex.push(0);\r\n    }\r\n\r\n    switch (geometry.getType()) {\r\n      case 'MultiLineString':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'Polygon':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'MultiPolygon':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\r\n        break;\r\n      case 'LineString':\r\n        coordinates = geometry.getCoordinates();\r\n        coordinates.splice(index + 1, 0, vertex);\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    this.setGeometryCoordinates_(geometry, coordinates);\r\n    const rTree = this.rBush_;\r\n    rTree.remove(segmentData);\r\n    this.updateSegmentIndices_(geometry, index, depth, 1);\r\n\r\n    /** @type {SegmentData} */\r\n    const newSegmentData = {\r\n      segment: [segment[0], vertex],\r\n      feature: feature,\r\n      geometry: geometry,\r\n      depth: depth,\r\n      index: index,\r\n    };\r\n\r\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\r\n    this.dragSegments_.push([newSegmentData, 1]);\r\n\r\n    /** @type {SegmentData} */\r\n    const newSegmentData2 = {\r\n      segment: [vertex, segment[1]],\r\n      feature: feature,\r\n      geometry: geometry,\r\n      depth: depth,\r\n      index: index + 1,\r\n    };\r\n\r\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\r\n    this.dragSegments_.push([newSegmentData2, 0]);\r\n    this.ignoreNextSingleClick_ = true;\r\n  }\r\n\r\n  /**\r\n   * Removes the vertex currently being pointed.\r\n   * @return {boolean} True when a vertex was removed.\r\n   * @api\r\n   */\r\n  removePoint() {\r\n    if (\r\n      this.lastPointerEvent_ &&\r\n      this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG\r\n    ) {\r\n      const evt = this.lastPointerEvent_;\r\n      this.willModifyFeatures_(evt, this.dragSegments_);\r\n      const removed = this.removeVertex_();\r\n      if (this.featuresBeingModified_) {\r\n        this.dispatchEvent(\r\n          new ModifyEvent(\r\n            ModifyEventType.MODIFYEND,\r\n            this.featuresBeingModified_,\r\n            evt,\r\n          ),\r\n        );\r\n      }\r\n\r\n      this.featuresBeingModified_ = null;\r\n      return removed;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Removes a vertex from all matching features.\r\n   * @return {boolean} True when a vertex was removed.\r\n   * @private\r\n   */\r\n  removeVertex_() {\r\n    const dragSegments = this.dragSegments_;\r\n    const segmentsByFeature = {};\r\n    let deleted = false;\r\n    let component, coordinates, dragSegment, geometry, i, index, left;\r\n    let newIndex, right, segmentData, uid;\r\n    for (i = dragSegments.length - 1; i >= 0; --i) {\r\n      dragSegment = dragSegments[i];\r\n      segmentData = dragSegment[0];\r\n      uid = getUid(segmentData.feature);\r\n      if (segmentData.depth) {\r\n        // separate feature components\r\n        uid += '-' + segmentData.depth.join('-');\r\n      }\r\n      if (!(uid in segmentsByFeature)) {\r\n        segmentsByFeature[uid] = {};\r\n      }\r\n      if (dragSegment[1] === 0) {\r\n        segmentsByFeature[uid].right = segmentData;\r\n        segmentsByFeature[uid].index = segmentData.index;\r\n      } else if (dragSegment[1] == 1) {\r\n        segmentsByFeature[uid].left = segmentData;\r\n        segmentsByFeature[uid].index = segmentData.index + 1;\r\n      }\r\n    }\r\n    for (uid in segmentsByFeature) {\r\n      right = segmentsByFeature[uid].right;\r\n      left = segmentsByFeature[uid].left;\r\n      index = segmentsByFeature[uid].index;\r\n      newIndex = index - 1;\r\n      if (left !== undefined) {\r\n        segmentData = left;\r\n      } else {\r\n        segmentData = right;\r\n      }\r\n      if (newIndex < 0) {\r\n        newIndex = 0;\r\n      }\r\n      geometry = segmentData.geometry;\r\n      coordinates = geometry.getCoordinates();\r\n      component = coordinates;\r\n      deleted = false;\r\n      switch (geometry.getType()) {\r\n        case 'MultiLineString':\r\n          if (coordinates[segmentData.depth[0]].length > 2) {\r\n            coordinates[segmentData.depth[0]].splice(index, 1);\r\n            deleted = true;\r\n          }\r\n          break;\r\n        case 'LineString':\r\n          if (coordinates.length > 2) {\r\n            coordinates.splice(index, 1);\r\n            deleted = true;\r\n          }\r\n          break;\r\n        case 'MultiPolygon':\r\n          component = component[segmentData.depth[1]];\r\n        /* falls through */\r\n        case 'Polygon':\r\n          component = component[segmentData.depth[0]];\r\n          if (component.length > 4) {\r\n            if (index == component.length - 1) {\r\n              index = 0;\r\n            }\r\n            component.splice(index, 1);\r\n            deleted = true;\r\n            if (index === 0) {\r\n              // close the ring again\r\n              component.pop();\r\n              component.push(component[0]);\r\n              newIndex = component.length - 1;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n        // pass\r\n      }\r\n\r\n      if (deleted) {\r\n        this.setGeometryCoordinates_(geometry, coordinates);\r\n        const segments = [];\r\n        if (left !== undefined) {\r\n          this.rBush_.remove(left);\r\n          segments.push(left.segment[0]);\r\n        }\r\n        if (right !== undefined) {\r\n          this.rBush_.remove(right);\r\n          segments.push(right.segment[1]);\r\n        }\r\n        if (left !== undefined && right !== undefined) {\r\n          /** @type {SegmentData} */\r\n          const newSegmentData = {\r\n            depth: segmentData.depth,\r\n            feature: segmentData.feature,\r\n            geometry: segmentData.geometry,\r\n            index: newIndex,\r\n            segment: segments,\r\n          };\r\n\r\n          this.rBush_.insert(\r\n            boundingExtent(newSegmentData.segment),\r\n            newSegmentData,\r\n          );\r\n        }\r\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\r\n        if (this.vertexFeature_) {\r\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\r\n          this.vertexFeature_ = null;\r\n        }\r\n        dragSegments.length = 0;\r\n      }\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n   * @param {Array} coordinates Coordinates.\r\n   * @private\r\n   */\r\n  setGeometryCoordinates_(geometry, coordinates) {\r\n    this.changingFeature_ = true;\r\n    geometry.setCoordinates(coordinates);\r\n    this.changingFeature_ = false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n   * @param {number} index Index.\r\n   * @param {Array<number>|undefined} depth Depth.\r\n   * @param {number} delta Delta (1 or -1).\r\n   * @private\r\n   */\r\n  updateSegmentIndices_(geometry, index, depth, delta) {\r\n    this.rBush_.forEachInExtent(\r\n      geometry.getExtent(),\r\n      function (segmentDataMatch) {\r\n        if (\r\n          segmentDataMatch.geometry === geometry &&\r\n          (depth === undefined ||\r\n            segmentDataMatch.depth === undefined ||\r\n            equals(segmentDataMatch.depth, depth)) &&\r\n          segmentDataMatch.index > index\r\n        ) {\r\n          segmentDataMatch.index += delta;\r\n        }\r\n      },\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {SegmentData} a The first segment data.\r\n * @param {SegmentData} b The second segment data.\r\n * @return {number} The difference in indexes.\r\n */\r\nfunction compareIndexes(a, b) {\r\n  return a.index - b.index;\r\n}\r\n\r\n/**\r\n * Returns the distance from a point to a line segment.\r\n *\r\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\r\n *        which to calculate the distance.\r\n * @param {SegmentData} segmentData The object describing the line\r\n *        segment we are calculating the distance to.\r\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n * @return {number} The square of the distance between a point and a line segment.\r\n */\r\nfunction projectedDistanceToSegmentDataSquared(\r\n  pointCoordinates,\r\n  segmentData,\r\n  projection,\r\n) {\r\n  const geometry = segmentData.geometry;\r\n\r\n  if (geometry.getType() === 'Circle') {\r\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n      geometry\r\n    );\r\n\r\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\r\n      const userProjection = getUserProjection();\r\n      if (userProjection) {\r\n        circleGeometry = circleGeometry\r\n          .clone()\r\n          .transform(userProjection, projection);\r\n      }\r\n      const distanceToCenterSquared = squaredCoordinateDistance(\r\n        circleGeometry.getCenter(),\r\n        fromUserCoordinate(pointCoordinates, projection),\r\n      );\r\n      const distanceToCircumference =\r\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\r\n      return distanceToCircumference * distanceToCircumference;\r\n    }\r\n  }\r\n\r\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\r\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\r\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\r\n  return squaredDistanceToSegment(coordinate, tempSegment);\r\n}\r\n\r\n/**\r\n * Returns the point closest to a given line segment.\r\n *\r\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\r\n *        should be found.\r\n * @param {SegmentData} segmentData The object describing the line\r\n *        segment which should contain the closest point.\r\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\r\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\r\n */\r\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\r\n  const geometry = segmentData.geometry;\r\n\r\n  if (\r\n    geometry.getType() === 'Circle' &&\r\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\r\n  ) {\r\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\r\n      geometry\r\n    );\r\n    const userProjection = getUserProjection();\r\n    if (userProjection) {\r\n      circleGeometry = circleGeometry\r\n        .clone()\r\n        .transform(userProjection, projection);\r\n    }\r\n    return toUserCoordinate(\r\n      circleGeometry.getClosestPoint(\r\n        fromUserCoordinate(pointCoordinates, projection),\r\n      ),\r\n      projection,\r\n    );\r\n  }\r\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\r\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\r\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\r\n  return toUserCoordinate(\r\n    closestOnSegment(coordinate, tempSegment),\r\n    projection,\r\n  );\r\n}\r\n\r\n/**\r\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\r\n */\r\nfunction getDefaultStyleFunction() {\r\n  const style = createEditingStyle();\r\n  return function (feature, resolution) {\r\n    return style['Point'];\r\n  };\r\n}\r\n\r\nexport default Modify;\r\n"],
  "mappings": "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",
  "names": ["Vector_default", "geometry", "equals", "coordinate", "buffer"]
}
