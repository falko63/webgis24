{
  "version": 3,
  "sources": ["../../ol/TileCache.js"],
  "sourcesContent": ["/**\r\n * @module ol/TileCache\r\n */\r\nimport LRUCache from './structs/LRUCache.js';\r\nimport {fromKey, getKey} from './tilecoord.js';\r\n\r\nclass TileCache extends LRUCache {\r\n  /**\r\n   * @override\r\n   */\r\n  clear() {\r\n    while (this.getCount() > 0) {\r\n      this.pop().release();\r\n    }\r\n    super.clear();\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   * @override\r\n   */\r\n  expireCache(usedTiles) {\r\n    while (this.canExpireCache()) {\r\n      const tile = this.peekLast();\r\n      if (tile.getKey() in usedTiles) {\r\n        break;\r\n      } else {\r\n        this.pop().release();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\r\n   */\r\n  pruneExceptNewestZ() {\r\n    if (this.getCount() === 0) {\r\n      return;\r\n    }\r\n    const key = this.peekFirstKey();\r\n    const tileCoord = fromKey(key);\r\n    const z = tileCoord[0];\r\n    this.forEach((tile) => {\r\n      if (tile.tileCoord[0] !== z) {\r\n        this.remove(getKey(tile.tileCoord));\r\n        tile.release();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default TileCache;\r\n"],
  "mappings": ";;;;;;;AAMA,IAAM,YAAN,cAAwB,iBAAS;AAAA;AAAA;AAAA;AAAA,EAI/B,QAAQ;AACN,WAAO,KAAK,SAAS,IAAI,GAAG;AAC1B,WAAK,IAAI,EAAE,QAAQ;AAAA,IACrB;AACA,UAAM,MAAM;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,WAAW;AACrB,WAAO,KAAK,eAAe,GAAG;AAC5B,YAAM,OAAO,KAAK,SAAS;AAC3B,UAAI,KAAK,OAAO,KAAK,WAAW;AAC9B;AAAA,MACF,OAAO;AACL,aAAK,IAAI,EAAE,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB;AACnB,QAAI,KAAK,SAAS,MAAM,GAAG;AACzB;AAAA,IACF;AACA,UAAM,MAAM,KAAK,aAAa;AAC9B,UAAM,YAAY,QAAQ,GAAG;AAC7B,UAAM,IAAI,UAAU,CAAC;AACrB,SAAK,QAAQ,CAAC,SAAS;AACrB,UAAI,KAAK,UAAU,CAAC,MAAM,GAAG;AAC3B,aAAK,OAAO,OAAO,KAAK,SAAS,CAAC;AAClC,aAAK,QAAQ;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAO,oBAAQ;",
  "names": []
}
