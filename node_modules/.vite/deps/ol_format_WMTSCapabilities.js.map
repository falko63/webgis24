{
  "version": 3,
  "sources": ["../../ol/xml.js", "../../ol/format/XML.js", "../../ol/format/xlink.js", "../../ol/format/xsd.js", "../../ol/format/OWS.js", "../../ol/format/WMTSCapabilities.js"],
  "sourcesContent": ["/**\r\n * @module ol/xml\r\n */\r\nimport {extend} from './array.js';\r\n\r\n/**\r\n * When using {@link module:ol/xml.makeChildAppender} or\r\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\r\n * to have this structure.\r\n * @typedef {Object} NodeStackItem\r\n * @property {Element} node Node.\r\n */\r\n\r\n/**\r\n * @typedef {function(Element, Array<*>): void} Parser\r\n */\r\n\r\n/**\r\n * @typedef {function(Element, *, Array<*>): void} Serializer\r\n */\r\n\r\n/**\r\n * @type {string}\r\n */\r\nexport const XML_SCHEMA_INSTANCE_URI =\r\n  'http://www.w3.org/2001/XMLSchema-instance';\r\n\r\n/**\r\n * @param {string} namespaceURI Namespace URI.\r\n * @param {string} qualifiedName Qualified name.\r\n * @return {Element} Node.\r\n */\r\nexport function createElementNS(namespaceURI, qualifiedName) {\r\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\r\n}\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @return {string} All text content.\r\n * @api\r\n */\r\nexport function getAllTextContent(node, normalizeWhitespace) {\r\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\r\n}\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @param {Array<string>} accumulator Accumulator.\r\n * @private\r\n * @return {Array<string>} Accumulator.\r\n */\r\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\r\n  if (\r\n    node.nodeType == Node.CDATA_SECTION_NODE ||\r\n    node.nodeType == Node.TEXT_NODE\r\n  ) {\r\n    if (normalizeWhitespace) {\r\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\r\n    } else {\r\n      accumulator.push(node.nodeValue);\r\n    }\r\n  } else {\r\n    let n;\r\n    for (n = node.firstChild; n; n = n.nextSibling) {\r\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\r\n    }\r\n  }\r\n  return accumulator;\r\n}\r\n\r\n/**\r\n * @param {Object} object Object.\r\n * @return {boolean} Is a document.\r\n */\r\nexport function isDocument(object) {\r\n  return 'documentElement' in object;\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {?string} namespaceURI Namespace URI.\r\n * @param {string} name Attribute name.\r\n * @return {string} Value\r\n */\r\nexport function getAttributeNS(node, namespaceURI, name) {\r\n  return node.getAttributeNS(namespaceURI, name) || '';\r\n}\r\n\r\n/**\r\n * Parse an XML string to an XML Document.\r\n * @param {string} xml XML.\r\n * @return {Document} Document.\r\n * @api\r\n */\r\nexport function parse(xml) {\r\n  return new DOMParser().parseFromString(xml, 'application/xml');\r\n}\r\n\r\n/**\r\n * Make an array extender function for extending the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayExtender(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array<*>} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        extend(array, value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an array pusher function for pushing to the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayPusher(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array<*>} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        array.push(value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object stack replacer function for replacing the object at the\r\n * top of the stack.\r\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeReplacer(valueReader, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\r\n      if (value !== undefined) {\r\n        objectStack[objectStack.length - 1] = value;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object property pusher function for adding a property to the\r\n * object at the top of the stack.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {string} [property] Property.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        const name = property !== undefined ? property : node.localName;\r\n        let array;\r\n        if (name in object) {\r\n          array = object[name];\r\n        } else {\r\n          array = [];\r\n          object[name] = array;\r\n        }\r\n        array.push(value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Make an object property setter function.\r\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\r\n * @param {string} [property] Property.\r\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\r\n * @return {Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, objectStack) {\r\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (\r\n          objectStack[objectStack.length - 1]\r\n        );\r\n        const name = property !== undefined ? property : node.localName;\r\n        object[name] = value;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Create a serializer that appends nodes written by its `nodeWriter` to its\r\n * designated parent. The parent is the `node` of the\r\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\r\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\r\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\r\n * @return {Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeChildAppender(nodeWriter, thisArg) {\r\n  return (\r\n    /**\r\n     * @param {Element} node Node.\r\n     * @param {*} value Value to be written.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @this {*}\r\n     */\r\n    function (node, value, objectStack) {\r\n      nodeWriter.call(thisArg ?? this, node, value, objectStack);\r\n      const parent = /** @type {NodeStackItem} */ (\r\n        objectStack[objectStack.length - 1]\r\n      );\r\n      const parentNode = parent.node;\r\n      parentNode.appendChild(node);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Create a serializer that calls the provided `nodeWriter` from\r\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\r\n * `nodeWriter` called with an array of values when the `nodeWriter` was\r\n * designed to serialize a single item. An example would be a LineString\r\n * geometry writer, which could be reused for writing MultiLineString\r\n * geometries.\r\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\r\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\r\n * @return {Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeArraySerializer(nodeWriter, thisArg) {\r\n  let serializersNS, nodeFactory;\r\n  return function (node, value, objectStack) {\r\n    if (serializersNS === undefined) {\r\n      serializersNS = {};\r\n      const serializers = {};\r\n      serializers[node.localName] = nodeWriter;\r\n      serializersNS[node.namespaceURI] = serializers;\r\n      nodeFactory = makeSimpleNodeFactory(node.localName);\r\n    }\r\n    serialize(serializersNS, nodeFactory, value, objectStack);\r\n  };\r\n}\r\n\r\n/**\r\n * Create a node factory which can use the `keys` passed to\r\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\r\n * or a fixed node name. The namespace of the created nodes can either be fixed,\r\n * or the parent namespace will be used.\r\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\r\n *     created nodes. If not provided, the 3rd argument to the resulting node\r\n *     factory needs to be provided and will be the nodeName.\r\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\r\n *     all created nodes. If not provided, the namespace of the parent node will\r\n *     be used.\r\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\r\n */\r\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\r\n  return (\r\n    /**\r\n     * @param {*} value Value.\r\n     * @param {Array<*>} objectStack Object stack.\r\n     * @param {string} [newNodeName] Node name.\r\n     * @return {Node} Node.\r\n     */\r\n    function (value, objectStack, newNodeName) {\r\n      const context = /** @type {NodeStackItem} */ (\r\n        objectStack[objectStack.length - 1]\r\n      );\r\n      const node = context.node;\r\n      let nodeName = fixedNodeName;\r\n      if (nodeName === undefined) {\r\n        nodeName = newNodeName;\r\n      }\r\n\r\n      const namespaceURI =\r\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\r\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * A node factory that creates a node using the parent's `namespaceURI` and the\r\n * `nodeName` passed by {@link module:ol/xml.serialize} or\r\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\r\n * @const\r\n * @type {function(*, Array<*>, string=): (Node|undefined)}\r\n */\r\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\r\n\r\n/**\r\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\r\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\r\n * `key` argument.\r\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\r\n *     be a subset of the `orderedKeys`.\r\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\r\n * @return {Array<*>} Values in the order of the sequence. The resulting array\r\n *     has the same length as the `orderedKeys` array. Values that are not\r\n *     present in `object` will be `undefined` in the resulting array.\r\n */\r\nexport function makeSequence(object, orderedKeys) {\r\n  const length = orderedKeys.length;\r\n  const sequence = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    sequence[i] = object[orderedKeys[i]];\r\n  }\r\n  return sequence;\r\n}\r\n\r\n/**\r\n * Create a namespaced structure, using the same values for each namespace.\r\n * This can be used as a starting point for versioned parsers, when only a few\r\n * values are version specific.\r\n * @param {Array<string>} namespaceURIs Namespace URIs.\r\n * @param {T} structure Structure.\r\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\r\n * @return {Object<string, T>} Namespaced structure.\r\n * @template T\r\n */\r\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\r\n  structureNS = structureNS !== undefined ? structureNS : {};\r\n  let i, ii;\r\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\r\n    structureNS[namespaceURIs[i]] = structure;\r\n  }\r\n  return structureNS;\r\n}\r\n\r\n/**\r\n * Parse a node using the parsers and object stack.\r\n * @param {Object<string, Object<string, Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {*} [thisArg] The object to use as `this`.\r\n */\r\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\r\n  let n;\r\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n    const parsers = parsersNS[n.namespaceURI];\r\n    if (parsers !== undefined) {\r\n      const parser = parsers[n.localName];\r\n      if (parser !== undefined) {\r\n        parser.call(thisArg, n, objectStack);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Push an object on top of the stack, parse and return the popped object.\r\n * @param {T} object Object.\r\n * @param {Object<string, Object<string, Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {*} [thisArg] The object to use as `this`.\r\n * @return {T} Object.\r\n * @template T\r\n */\r\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\r\n  objectStack.push(object);\r\n  parseNode(parsersNS, node, objectStack, thisArg);\r\n  return /** @type {T} */ (objectStack.pop());\r\n}\r\n\r\n/**\r\n * Walk through an array of `values` and call a serializer for each value.\r\n * @param {Object<string, Object<string, Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array<*>} objectStack Node stack.\r\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `keys` has\r\n *     to match the length of `values`. For serializing a sequence, `keys`\r\n *     determines the order of the sequence.\r\n * @param {T} [thisArg] The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @template T\r\n */\r\nexport function serialize(\r\n  serializersNS,\r\n  nodeFactory,\r\n  values,\r\n  objectStack,\r\n  keys,\r\n  thisArg,\r\n) {\r\n  const length = (keys !== undefined ? keys : values).length;\r\n  let value, node;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = values[i];\r\n    if (value !== undefined) {\r\n      node = nodeFactory.call(\r\n        thisArg,\r\n        value,\r\n        objectStack,\r\n        keys !== undefined ? keys[i] : undefined,\r\n      );\r\n      if (node !== undefined) {\r\n        serializersNS[node.namespaceURI][node.localName].call(\r\n          thisArg,\r\n          node,\r\n          value,\r\n          objectStack,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {O} object Object.\r\n * @param {Object<string, Object<string, Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array<*>} objectStack Node stack.\r\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `keys` has\r\n *     to match the length of `values`. For serializing a sequence, `keys`\r\n *     determines the order of the sequence.\r\n * @param {T} [thisArg] The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @return {O|undefined} Object.\r\n * @template O, T\r\n */\r\nexport function pushSerializeAndPop(\r\n  object,\r\n  serializersNS,\r\n  nodeFactory,\r\n  values,\r\n  objectStack,\r\n  keys,\r\n  thisArg,\r\n) {\r\n  objectStack.push(object);\r\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\r\n  return /** @type {O|undefined} */ (objectStack.pop());\r\n}\r\n\r\nlet xmlSerializer_ = undefined;\r\n\r\n/**\r\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\r\n * where there is no globally available implementation.\r\n *\r\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\r\n * @api\r\n */\r\nexport function registerXMLSerializer(xmlSerializer) {\r\n  xmlSerializer_ = xmlSerializer;\r\n}\r\n\r\n/**\r\n * @return {XMLSerializer} The XMLSerializer.\r\n */\r\nexport function getXMLSerializer() {\r\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\r\n    xmlSerializer_ = new XMLSerializer();\r\n  }\r\n  return xmlSerializer_;\r\n}\r\n\r\nlet document_ = undefined;\r\n\r\n/**\r\n * Register a Document to use when creating nodes for XML serializations. Can be used\r\n * to inject a Document where there is no globally available implementation.\r\n *\r\n * @param {Document} document A Document.\r\n * @api\r\n */\r\nexport function registerDocument(document) {\r\n  document_ = document;\r\n}\r\n\r\n/**\r\n * Get a document that should be used when creating nodes for XML serializations.\r\n * @return {Document} The document.\r\n */\r\nexport function getDocument() {\r\n  if (document_ === undefined && typeof document !== 'undefined') {\r\n    document_ = document.implementation.createDocument('', '', null);\r\n  }\r\n  return document_;\r\n}\r\n", "/**\r\n * @module ol/format/XML\r\n */\r\nimport {abstract} from '../util.js';\r\nimport {isDocument, parse} from '../xml.js';\r\n\r\n/**\r\n * @classdesc\r\n * Generic format for reading non-feature XML data\r\n *\r\n * @abstract\r\n */\r\nclass XML {\r\n  /**\r\n   * Read the source document.\r\n   *\r\n   * @param {Document|Element|string} source The XML source.\r\n   * @return {Object|null} An object representing the source.\r\n   * @api\r\n   */\r\n  read(source) {\r\n    if (!source) {\r\n      return null;\r\n    }\r\n    if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readFromDocument(doc);\r\n    }\r\n    if (isDocument(source)) {\r\n      return this.readFromDocument(/** @type {Document} */ (source));\r\n    }\r\n    return this.readFromNode(/** @type {Element} */ (source));\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {Object|null} Object\r\n   */\r\n  readFromDocument(doc) {\r\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        return this.readFromNode(/** @type {Element} */ (n));\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Element} node Node.\r\n   * @return {Object|null} Object\r\n   */\r\n  readFromNode(node) {\r\n    abstract();\r\n  }\r\n}\r\n\r\nexport default XML;\r\n", "/**\r\n * @module ol/format/xlink\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst NAMESPACE_URI = 'http://www.w3.org/1999/xlink';\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @return {string|null} href.\r\n */\r\nexport function readHref(node) {\r\n  return node.getAttributeNS(NAMESPACE_URI, 'href');\r\n}\r\n", "/**\r\n * @module ol/format/xsd\r\n */\r\nimport {getAllTextContent, getDocument} from '../xml.js';\r\nimport {padNumber} from '../string.js';\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {boolean|undefined} Boolean.\r\n */\r\nexport function readBoolean(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readBooleanString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {boolean|undefined} Boolean.\r\n */\r\nexport function readBooleanString(string) {\r\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\r\n  if (m) {\r\n    return m[1] !== undefined || false;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} DateTime in seconds.\r\n */\r\nexport function readDateTime(node) {\r\n  const s = getAllTextContent(node, false);\r\n  const dateTime = Date.parse(s);\r\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} Decimal.\r\n */\r\nexport function readDecimal(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readDecimalString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {number|undefined} Decimal.\r\n */\r\nexport function readDecimalString(string) {\r\n  // FIXME check spec\r\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\r\n  if (m) {\r\n    return parseFloat(m[1]);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {number|undefined} Non negative integer.\r\n */\r\nexport function readPositiveInteger(node) {\r\n  const s = getAllTextContent(node, false);\r\n  return readNonNegativeIntegerString(s);\r\n}\r\n\r\n/**\r\n * @param {string} string String.\r\n * @return {number|undefined} Non negative integer.\r\n */\r\nexport function readNonNegativeIntegerString(string) {\r\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\r\n  if (m) {\r\n    return parseInt(m[1], 10);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @return {string|undefined} String.\r\n */\r\nexport function readString(node) {\r\n  return getAllTextContent(node, false).trim();\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the boolean to.\r\n * @param {boolean} bool Boolean.\r\n */\r\nexport function writeBooleanTextNode(node, bool) {\r\n  writeStringTextNode(node, bool ? '1' : '0');\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a CDATA Section with the string to.\r\n * @param {string} string String.\r\n */\r\nexport function writeCDATASection(node, string) {\r\n  node.appendChild(getDocument().createCDATASection(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the dateTime to.\r\n * @param {number} dateTime DateTime in seconds.\r\n */\r\nexport function writeDateTimeTextNode(node, dateTime) {\r\n  const date = new Date(dateTime * 1000);\r\n  const string =\r\n    date.getUTCFullYear() +\r\n    '-' +\r\n    padNumber(date.getUTCMonth() + 1, 2) +\r\n    '-' +\r\n    padNumber(date.getUTCDate(), 2) +\r\n    'T' +\r\n    padNumber(date.getUTCHours(), 2) +\r\n    ':' +\r\n    padNumber(date.getUTCMinutes(), 2) +\r\n    ':' +\r\n    padNumber(date.getUTCSeconds(), 2) +\r\n    'Z';\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the decimal to.\r\n * @param {number} decimal Decimal.\r\n */\r\nexport function writeDecimalTextNode(node, decimal) {\r\n  const string = decimal.toPrecision();\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the decimal to.\r\n * @param {number} nonNegativeInteger Non negative integer.\r\n */\r\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\r\n  const string = nonNegativeInteger.toString();\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node to append a TextNode with the string to.\r\n * @param {string} string String.\r\n */\r\nexport function writeStringTextNode(node, string) {\r\n  node.appendChild(getDocument().createTextNode(string));\r\n}\r\n", "/**\r\n * @module ol/format/OWS\r\n */\r\nimport XML from './XML.js';\r\nimport {\r\n  makeObjectPropertyPusher,\r\n  makeObjectPropertySetter,\r\n  makeStructureNS,\r\n  pushParseAndPop,\r\n} from '../xml.js';\r\nimport {readHref} from './xlink.js';\r\nimport {readString} from './xsd.js';\r\n\r\n/**\r\n * @const\r\n * @type {Array<null|string>}\r\n */\r\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'ServiceIdentification': makeObjectPropertySetter(readServiceIdentification),\r\n  'ServiceProvider': makeObjectPropertySetter(readServiceProvider),\r\n  'OperationsMetadata': makeObjectPropertySetter(readOperationsMetadata),\r\n});\r\n\r\nclass OWS extends XML {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {Object|null} Object\r\n   * @override\r\n   */\r\n  readFromNode(node) {\r\n    const owsObject = pushParseAndPop({}, PARSERS, node, []);\r\n    return owsObject ? owsObject : null;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'DeliveryPoint': makeObjectPropertySetter(readString),\r\n  'City': makeObjectPropertySetter(readString),\r\n  'AdministrativeArea': makeObjectPropertySetter(readString),\r\n  'PostalCode': makeObjectPropertySetter(readString),\r\n  'Country': makeObjectPropertySetter(readString),\r\n  'ElectronicMailAddress': makeObjectPropertySetter(readString),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Value': makeObjectPropertyPusher(readValue),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'AllowedValues': makeObjectPropertySetter(readAllowedValues),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Phone': makeObjectPropertySetter(readPhone),\r\n  'Address': makeObjectPropertySetter(readAddress),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst DCP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'HTTP': makeObjectPropertySetter(readHttp),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Get': makeObjectPropertyPusher(readGet),\r\n  'Post': undefined, // TODO\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'DCP': makeObjectPropertySetter(readDcp),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Operation': readOperation,\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Voice': makeObjectPropertySetter(readString),\r\n  'Facsimile': makeObjectPropertySetter(readString),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Constraint': makeObjectPropertyPusher(readConstraint),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'IndividualName': makeObjectPropertySetter(readString),\r\n  'PositionName': makeObjectPropertySetter(readString),\r\n  'ContactInfo': makeObjectPropertySetter(readContactInfo),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Abstract': makeObjectPropertySetter(readString),\r\n  'AccessConstraints': makeObjectPropertySetter(readString),\r\n  'Fees': makeObjectPropertySetter(readString),\r\n  'Title': makeObjectPropertySetter(readString),\r\n  'ServiceTypeVersion': makeObjectPropertySetter(readString),\r\n  'ServiceType': makeObjectPropertySetter(readString),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'ProviderName': makeObjectPropertySetter(readString),\r\n  'ProviderSite': makeObjectPropertySetter(readHref),\r\n  'ServiceContact': makeObjectPropertySetter(readServiceContact),\r\n});\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The address.\r\n */\r\nfunction readAddress(node, objectStack) {\r\n  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The values.\r\n */\r\nfunction readAllowedValues(node, objectStack) {\r\n  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The constraint.\r\n */\r\nfunction readConstraint(node, objectStack) {\r\n  const name = node.getAttribute('name');\r\n  if (!name) {\r\n    return undefined;\r\n  }\r\n  return pushParseAndPop({'name': name}, CONSTRAINT_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The contact info.\r\n */\r\nfunction readContactInfo(node, objectStack) {\r\n  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The DCP.\r\n */\r\nfunction readDcp(node, objectStack) {\r\n  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The GET object.\r\n */\r\nfunction readGet(node, objectStack) {\r\n  const href = readHref(node);\r\n  if (!href) {\r\n    return undefined;\r\n  }\r\n  return pushParseAndPop(\r\n    {'href': href},\r\n    REQUEST_METHOD_PARSERS,\r\n    node,\r\n    objectStack,\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The HTTP object.\r\n */\r\nfunction readHttp(node, objectStack) {\r\n  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The operation.\r\n */\r\nfunction readOperation(node, objectStack) {\r\n  const name = node.getAttribute('name');\r\n  const value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);\r\n  if (!value) {\r\n    return undefined;\r\n  }\r\n  const object = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  object[name] = value;\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The operations metadata.\r\n */\r\nfunction readOperationsMetadata(node, objectStack) {\r\n  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The phone.\r\n */\r\nfunction readPhone(node, objectStack) {\r\n  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The service identification.\r\n */\r\nfunction readServiceIdentification(node, objectStack) {\r\n  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The service contact.\r\n */\r\nfunction readServiceContact(node, objectStack) {\r\n  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} The service provider.\r\n */\r\nfunction readServiceProvider(node, objectStack) {\r\n  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {string|undefined} The value.\r\n */\r\nfunction readValue(node, objectStack) {\r\n  return readString(node);\r\n}\r\n\r\nexport default OWS;\r\n", "/**\r\n * @module ol/format/WMTSCapabilities\r\n */\r\nimport OWS from './OWS.js';\r\nimport XML from './XML.js';\r\nimport {boundingExtent} from '../extent.js';\r\nimport {\r\n  makeArrayPusher,\r\n  makeObjectPropertyPusher,\r\n  makeObjectPropertySetter,\r\n  makeStructureNS,\r\n  pushParseAndPop,\r\n} from '../xml.js';\r\nimport {readDecimal, readPositiveInteger, readString} from './xsd.js';\r\nimport {readHref} from './xlink.js';\r\n\r\n/**\r\n * @const\r\n * @type {Array<null|string>}\r\n */\r\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/wmts/1.0'];\r\n\r\n/**\r\n * @const\r\n * @type {Array<null|string>}\r\n */\r\nconst OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Contents': makeObjectPropertySetter(readContents),\r\n});\r\n\r\n/**\r\n * @classdesc\r\n * Format for reading WMTS capabilities data.\r\n *\r\n * @api\r\n */\r\nclass WMTSCapabilities extends XML {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @type {OWS}\r\n     * @private\r\n     */\r\n    this.owsParser_ = new OWS();\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {Object|null} Object\r\n   * @override\r\n   */\r\n  readFromNode(node) {\r\n    let version = node.getAttribute('version');\r\n    if (version) {\r\n      version = version.trim();\r\n    }\r\n    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);\r\n    if (!WMTSCapabilityObject) {\r\n      return null;\r\n    }\r\n    WMTSCapabilityObject['version'] = version;\r\n    WMTSCapabilityObject = pushParseAndPop(\r\n      WMTSCapabilityObject,\r\n      PARSERS,\r\n      node,\r\n      [],\r\n    );\r\n    return WMTSCapabilityObject ? WMTSCapabilityObject : null;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'Layer': makeObjectPropertyPusher(readLayer),\r\n  'TileMatrixSet': makeObjectPropertyPusher(readTileMatrixSet),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst LAYER_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'Style': makeObjectPropertyPusher(readStyle),\r\n    'Format': makeObjectPropertyPusher(readString),\r\n    'TileMatrixSetLink': makeObjectPropertyPusher(readTileMatrixSetLink),\r\n    'Dimension': makeObjectPropertyPusher(readDimensions),\r\n    'ResourceURL': makeObjectPropertyPusher(readResourceUrl),\r\n  },\r\n  makeStructureNS(OWS_NAMESPACE_URIS, {\r\n    'Title': makeObjectPropertySetter(readString),\r\n    'Abstract': makeObjectPropertySetter(readString),\r\n    'WGS84BoundingBox': makeObjectPropertySetter(readBoundingBox),\r\n    'BoundingBox': makeObjectPropertyPusher(readBoundingBoxWithCrs),\r\n    'Identifier': makeObjectPropertySetter(readString),\r\n  }),\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst STYLE_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'LegendURL': makeObjectPropertyPusher(readLegendUrl),\r\n  },\r\n  makeStructureNS(OWS_NAMESPACE_URIS, {\r\n    'Title': makeObjectPropertySetter(readString),\r\n    'Identifier': makeObjectPropertySetter(readString),\r\n  }),\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'TileMatrixSet': makeObjectPropertySetter(readString),\r\n  'TileMatrixSetLimits': makeObjectPropertySetter(readTileMatrixLimitsList),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'TileMatrixLimits': makeArrayPusher(readTileMatrixLimits),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\r\n  'TileMatrix': makeObjectPropertySetter(readString),\r\n  'MinTileRow': makeObjectPropertySetter(readPositiveInteger),\r\n  'MaxTileRow': makeObjectPropertySetter(readPositiveInteger),\r\n  'MinTileCol': makeObjectPropertySetter(readPositiveInteger),\r\n  'MaxTileCol': makeObjectPropertySetter(readPositiveInteger),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst DIMENSION_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'Default': makeObjectPropertySetter(readString),\r\n    'Value': makeObjectPropertyPusher(readString),\r\n  },\r\n  makeStructureNS(OWS_NAMESPACE_URIS, {\r\n    'Identifier': makeObjectPropertySetter(readString),\r\n  }),\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {\r\n  'LowerCorner': makeArrayPusher(readCoordinates),\r\n  'UpperCorner': makeArrayPusher(readCoordinates),\r\n});\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst TMS_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'WellKnownScaleSet': makeObjectPropertySetter(readString),\r\n    'TileMatrix': makeObjectPropertyPusher(readTileMatrix),\r\n  },\r\n  makeStructureNS(OWS_NAMESPACE_URIS, {\r\n    'SupportedCRS': makeObjectPropertySetter(readString),\r\n    'Identifier': makeObjectPropertySetter(readString),\r\n    'BoundingBox': makeObjectPropertySetter(readBoundingBox),\r\n  }),\r\n);\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\n// @ts-ignore\r\nconst TM_PARSERS = makeStructureNS(\r\n  NAMESPACE_URIS,\r\n  {\r\n    'TopLeftCorner': makeObjectPropertySetter(readCoordinates),\r\n    'ScaleDenominator': makeObjectPropertySetter(readDecimal),\r\n    'TileWidth': makeObjectPropertySetter(readPositiveInteger),\r\n    'TileHeight': makeObjectPropertySetter(readPositiveInteger),\r\n    'MatrixWidth': makeObjectPropertySetter(readPositiveInteger),\r\n    'MatrixHeight': makeObjectPropertySetter(readPositiveInteger),\r\n  },\r\n  makeStructureNS(OWS_NAMESPACE_URIS, {\r\n    'Identifier': makeObjectPropertySetter(readString),\r\n  }),\r\n);\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Attribution object.\r\n */\r\nfunction readContents(node, objectStack) {\r\n  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Layers object.\r\n */\r\nfunction readLayer(node, objectStack) {\r\n  return pushParseAndPop({}, LAYER_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Tile Matrix Set object.\r\n */\r\nfunction readTileMatrixSet(node, objectStack) {\r\n  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Style object.\r\n */\r\nfunction readStyle(node, objectStack) {\r\n  const style = pushParseAndPop({}, STYLE_PARSERS, node, objectStack);\r\n  if (!style) {\r\n    return undefined;\r\n  }\r\n  const isDefault = node.getAttribute('isDefault') === 'true';\r\n  style['isDefault'] = isDefault;\r\n  return style;\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Tile Matrix Set Link object.\r\n */\r\nfunction readTileMatrixSetLink(node, objectStack) {\r\n  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Dimension object.\r\n */\r\nfunction readDimensions(node, objectStack) {\r\n  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Resource URL object.\r\n */\r\nfunction readResourceUrl(node, objectStack) {\r\n  const format = node.getAttribute('format');\r\n  const template = node.getAttribute('template');\r\n  const resourceType = node.getAttribute('resourceType');\r\n  const resource = {};\r\n  if (format) {\r\n    resource['format'] = format;\r\n  }\r\n  if (template) {\r\n    resource['template'] = template;\r\n  }\r\n  if (resourceType) {\r\n    resource['resourceType'] = resourceType;\r\n  }\r\n  return resource;\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} BBox object.\r\n */\r\nfunction readBoundingBox(node, objectStack) {\r\n  const coordinates = pushParseAndPop(\r\n    [],\r\n    WGS84_BBOX_READERS,\r\n    node,\r\n    objectStack,\r\n  );\r\n  if (coordinates.length != 2) {\r\n    return undefined;\r\n  }\r\n  return boundingExtent(coordinates);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} BBox object.\r\n */\r\nfunction readBoundingBoxWithCrs(node, objectStack) {\r\n  const crs = node.getAttribute('crs');\r\n  const coordinates = pushParseAndPop(\r\n    [],\r\n    WGS84_BBOX_READERS,\r\n    node,\r\n    objectStack,\r\n  );\r\n  if (coordinates.length != 2) {\r\n    return undefined;\r\n  }\r\n  return {extent: boundingExtent(coordinates), crs: crs};\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Legend object.\r\n */\r\nfunction readLegendUrl(node, objectStack) {\r\n  const legend = {};\r\n  legend['format'] = node.getAttribute('format');\r\n  legend['href'] = readHref(node);\r\n  return legend;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Coordinates object.\r\n */\r\nfunction readCoordinates(node, objectStack) {\r\n  const coordinates = readString(node).split(/\\s+/);\r\n  if (!coordinates || coordinates.length != 2) {\r\n    return undefined;\r\n  }\r\n  const x = +coordinates[0];\r\n  const y = +coordinates[1];\r\n  if (isNaN(x) || isNaN(y)) {\r\n    return undefined;\r\n  }\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} TileMatrix object.\r\n */\r\nfunction readTileMatrix(node, objectStack) {\r\n  return pushParseAndPop({}, TM_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} TileMatrixSetLimits Object.\r\n */\r\nfunction readTileMatrixLimitsList(node, objectStack) {\r\n  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} TileMatrixLimits Array.\r\n */\r\nfunction readTileMatrixLimits(node, objectStack) {\r\n  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);\r\n}\r\n\r\nexport default WMTSCapabilities;\r\n"],
  "mappings": ";;;;;;;;;;AAgCO,SAAS,gBAAgB,cAAc,eAAe;AAC3D,SAAO,YAAY,EAAE,gBAAgB,cAAc,aAAa;AAClE;AAUO,SAAS,kBAAkB,MAAM,qBAAqB;AAC3D,SAAO,mBAAmB,MAAM,qBAAqB,CAAC,CAAC,EAAE,KAAK,EAAE;AAClE;AAWO,SAAS,mBAAmB,MAAM,qBAAqB,aAAa;AACzE,MACE,KAAK,YAAY,KAAK,sBACtB,KAAK,YAAY,KAAK,WACtB;AACA,QAAI,qBAAqB;AACvB,kBAAY,KAAK,OAAO,KAAK,SAAS,EAAE,QAAQ,iBAAiB,EAAE,CAAC;AAAA,IACtE,OAAO;AACL,kBAAY,KAAK,KAAK,SAAS;AAAA,IACjC;AAAA,EACF,OAAO;AACL,QAAI;AACJ,SAAK,IAAI,KAAK,YAAY,GAAG,IAAI,EAAE,aAAa;AAC9C,yBAAmB,GAAG,qBAAqB,WAAW;AAAA,IACxD;AAAA,EACF;AACA,SAAO;AACT;AAMO,SAAS,WAAW,QAAQ;AACjC,SAAO,qBAAqB;AAC9B;AAkBO,SAAS,MAAM,KAAK;AACzB,SAAO,IAAI,UAAU,EAAE,gBAAgB,KAAK,iBAAiB;AAC/D;AAqCO,SAAS,gBAAgB,aAAa,SAAS;AACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAME,SAAU,MAAM,aAAa;AAC3B,YAAM,QAAQ,YAAY,KAAK,WAAW,MAAM,MAAM,WAAW;AACjE,UAAI,UAAU,QAAW;AACvB,cAAM;AAAA;AAAA,UACJ,YAAY,YAAY,SAAS,CAAC;AAAA;AAEpC,cAAM,KAAK,KAAK;AAAA,MAClB;AAAA,IACF;AAAA;AAEJ;AAmCO,SAAS,yBAAyB,aAAa,UAAU,SAAS;AACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAME,SAAU,MAAM,aAAa;AAC3B,YAAM,QAAQ,YAAY,KAAK,WAAW,MAAM,MAAM,WAAW;AACjE,UAAI,UAAU,QAAW;AACvB,cAAM;AAAA;AAAA,UACJ,YAAY,YAAY,SAAS,CAAC;AAAA;AAEpC,cAAM,OAAO,aAAa,SAAY,WAAW,KAAK;AACtD,YAAI;AACJ,YAAI,QAAQ,QAAQ;AAClB,kBAAQ,OAAO,IAAI;AAAA,QACrB,OAAO;AACL,kBAAQ,CAAC;AACT,iBAAO,IAAI,IAAI;AAAA,QACjB;AACA,cAAM,KAAK,KAAK;AAAA,MAClB;AAAA,IACF;AAAA;AAEJ;AAUO,SAAS,yBAAyB,aAAa,UAAU,SAAS;AACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAME,SAAU,MAAM,aAAa;AAC3B,YAAM,QAAQ,YAAY,KAAK,WAAW,MAAM,MAAM,WAAW;AACjE,UAAI,UAAU,QAAW;AACvB,cAAM;AAAA;AAAA,UACJ,YAAY,YAAY,SAAS,CAAC;AAAA;AAEpC,cAAM,OAAO,aAAa,SAAY,WAAW,KAAK;AACtD,eAAO,IAAI,IAAI;AAAA,MACjB;AAAA,IACF;AAAA;AAEJ;AAqEO,SAAS,sBAAsB,eAAe,mBAAmB;AACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOE,SAAU,OAAO,aAAa,aAAa;AACzC,YAAM;AAAA;AAAA,QACJ,YAAY,YAAY,SAAS,CAAC;AAAA;AAEpC,YAAM,OAAO,QAAQ;AACrB,UAAI,WAAW;AACf,UAAI,aAAa,QAAW;AAC1B,mBAAW;AAAA,MACb;AAEA,YAAM,eACJ,sBAAsB,SAAY,oBAAoB,KAAK;AAC7D,aAAO;AAAA,QAAgB;AAAA;AAAA,QAAqC;AAAA,MAAS;AAAA,IACvE;AAAA;AAEJ;AASO,IAAM,+BAA+B,sBAAsB;AAgC3D,SAAS,gBAAgB,eAAe,WAAW,aAAa;AACrE,gBAAc,gBAAgB,SAAY,cAAc,CAAC;AACzD,MAAI,GAAG;AACP,OAAK,IAAI,GAAG,KAAK,cAAc,QAAQ,IAAI,IAAI,EAAE,GAAG;AAClD,gBAAY,cAAc,CAAC,CAAC,IAAI;AAAA,EAClC;AACA,SAAO;AACT;AAUO,SAAS,UAAU,WAAW,MAAM,aAAa,SAAS;AAC/D,MAAI;AACJ,OAAK,IAAI,KAAK,mBAAmB,GAAG,IAAI,EAAE,oBAAoB;AAC5D,UAAM,UAAU,UAAU,EAAE,YAAY;AACxC,QAAI,YAAY,QAAW;AACzB,YAAM,SAAS,QAAQ,EAAE,SAAS;AAClC,UAAI,WAAW,QAAW;AACxB,eAAO,KAAK,SAAS,GAAG,WAAW;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACF;AAaO,SAAS,gBAAgB,QAAQ,WAAW,MAAM,aAAa,SAAS;AAC7E,cAAY,KAAK,MAAM;AACvB,YAAU,WAAW,MAAM,aAAa,OAAO;AAC/C;AAAA;AAAA,IAAyB,YAAY,IAAI;AAAA;AAC3C;AAmHA,IAAI,YAAY;AAiBT,SAAS,cAAc;AAC5B,MAAI,cAAc,UAAa,OAAO,aAAa,aAAa;AAC9D,gBAAY,SAAS,eAAe,eAAe,IAAI,IAAI,IAAI;AAAA,EACjE;AACA,SAAO;AACT;;;ACniBA,IAAM,MAAN,MAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQR,KAAK,QAAQ;AACX,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,QAAI,OAAO,WAAW,UAAU;AAC9B,YAAM,MAAM,MAAM,MAAM;AACxB,aAAO,KAAK,iBAAiB,GAAG;AAAA,IAClC;AACA,QAAI,WAAW,MAAM,GAAG;AACtB,aAAO,KAAK;AAAA;AAAA,QAA0C;AAAA,MAAO;AAAA,IAC/D;AACA,WAAO,KAAK;AAAA;AAAA,MAAqC;AAAA,IAAO;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,KAAK;AACpB,aAAS,IAAI,IAAI,YAAY,GAAG,IAAI,EAAE,aAAa;AACjD,UAAI,EAAE,YAAY,KAAK,cAAc;AACnC,eAAO,KAAK;AAAA;AAAA,UAAqC;AAAA,QAAE;AAAA,MACrD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAM;AACjB,aAAS;AAAA,EACX;AACF;AAEA,IAAO,cAAQ;;;ACjDf,IAAM,gBAAgB;AAMf,SAAS,SAAS,MAAM;AAC7B,SAAO,KAAK,eAAe,eAAe,MAAM;AAClD;;;ACyBO,SAAS,YAAY,MAAM;AAChC,QAAM,IAAI,kBAAkB,MAAM,KAAK;AACvC,SAAO,kBAAkB,CAAC;AAC5B;AAMO,SAAS,kBAAkB,QAAQ;AAExC,QAAM,IAAI,4CAA4C,KAAK,MAAM;AACjE,MAAI,GAAG;AACL,WAAO,WAAW,EAAE,CAAC,CAAC;AAAA,EACxB;AACA,SAAO;AACT;AAMO,SAAS,oBAAoB,MAAM;AACxC,QAAM,IAAI,kBAAkB,MAAM,KAAK;AACvC,SAAO,6BAA6B,CAAC;AACvC;AAMO,SAAS,6BAA6B,QAAQ;AACnD,QAAM,IAAI,gBAAgB,KAAK,MAAM;AACrC,MAAI,GAAG;AACL,WAAO,SAAS,EAAE,CAAC,GAAG,EAAE;AAAA,EAC1B;AACA,SAAO;AACT;AAMO,SAAS,WAAW,MAAM;AAC/B,SAAO,kBAAkB,MAAM,KAAK,EAAE,KAAK;AAC7C;;;ACrEA,IAAM,iBAAiB,CAAC,MAAM,gCAAgC;AAO9D,IAAM,UAAU,gBAAgB,gBAAgB;AAAA,EAC9C,yBAAyB,yBAAyB,yBAAyB;AAAA,EAC3E,mBAAmB,yBAAyB,mBAAmB;AAAA,EAC/D,sBAAsB,yBAAyB,sBAAsB;AACvE,CAAC;AAED,IAAM,MAAN,cAAkB,YAAI;AAAA,EACpB,cAAc;AACZ,UAAM;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAM;AACjB,UAAM,YAAY,gBAAgB,CAAC,GAAG,SAAS,MAAM,CAAC,CAAC;AACvD,WAAO,YAAY,YAAY;AAAA,EACjC;AACF;AAOA,IAAM,kBAAkB,gBAAgB,gBAAgB;AAAA,EACtD,iBAAiB,yBAAyB,UAAU;AAAA,EACpD,QAAQ,yBAAyB,UAAU;AAAA,EAC3C,sBAAsB,yBAAyB,UAAU;AAAA,EACzD,cAAc,yBAAyB,UAAU;AAAA,EACjD,WAAW,yBAAyB,UAAU;AAAA,EAC9C,yBAAyB,yBAAyB,UAAU;AAC9D,CAAC;AAOD,IAAM,yBAAyB,gBAAgB,gBAAgB;AAAA,EAC7D,SAAS,yBAAyB,SAAS;AAC7C,CAAC;AAOD,IAAM,qBAAqB,gBAAgB,gBAAgB;AAAA,EACzD,iBAAiB,yBAAyB,iBAAiB;AAC7D,CAAC;AAOD,IAAM,uBAAuB,gBAAgB,gBAAgB;AAAA,EAC3D,SAAS,yBAAyB,SAAS;AAAA,EAC3C,WAAW,yBAAyB,WAAW;AACjD,CAAC;AAOD,IAAM,cAAc,gBAAgB,gBAAgB;AAAA,EAClD,QAAQ,yBAAyB,QAAQ;AAC3C,CAAC;AAOD,IAAM,eAAe,gBAAgB,gBAAgB;AAAA,EACnD,OAAO,yBAAyB,OAAO;AAAA,EACvC,QAAQ;AAAA;AACV,CAAC;AAOD,IAAM,oBAAoB,gBAAgB,gBAAgB;AAAA,EACxD,OAAO,yBAAyB,OAAO;AACzC,CAAC;AAOD,IAAM,8BAA8B,gBAAgB,gBAAgB;AAAA,EAClE,aAAa;AACf,CAAC;AAOD,IAAM,gBAAgB,gBAAgB,gBAAgB;AAAA,EACpD,SAAS,yBAAyB,UAAU;AAAA,EAC5C,aAAa,yBAAyB,UAAU;AAClD,CAAC;AAOD,IAAM,yBAAyB,gBAAgB,gBAAgB;AAAA,EAC7D,cAAc,yBAAyB,cAAc;AACvD,CAAC;AAOD,IAAM,0BAA0B,gBAAgB,gBAAgB;AAAA,EAC9D,kBAAkB,yBAAyB,UAAU;AAAA,EACrD,gBAAgB,yBAAyB,UAAU;AAAA,EACnD,eAAe,yBAAyB,eAAe;AACzD,CAAC;AAOD,IAAM,iCAAiC,gBAAgB,gBAAgB;AAAA,EACrE,YAAY,yBAAyB,UAAU;AAAA,EAC/C,qBAAqB,yBAAyB,UAAU;AAAA,EACxD,QAAQ,yBAAyB,UAAU;AAAA,EAC3C,SAAS,yBAAyB,UAAU;AAAA,EAC5C,sBAAsB,yBAAyB,UAAU;AAAA,EACzD,eAAe,yBAAyB,UAAU;AACpD,CAAC;AAOD,IAAM,2BAA2B,gBAAgB,gBAAgB;AAAA,EAC/D,gBAAgB,yBAAyB,UAAU;AAAA,EACnD,gBAAgB,yBAAyB,QAAQ;AAAA,EACjD,kBAAkB,yBAAyB,kBAAkB;AAC/D,CAAC;AAOD,SAAS,YAAY,MAAM,aAAa;AACtC,SAAO,gBAAgB,CAAC,GAAG,iBAAiB,MAAM,WAAW;AAC/D;AAOA,SAAS,kBAAkB,MAAM,aAAa;AAC5C,SAAO,gBAAgB,CAAC,GAAG,wBAAwB,MAAM,WAAW;AACtE;AAOA,SAAS,eAAe,MAAM,aAAa;AACzC,QAAM,OAAO,KAAK,aAAa,MAAM;AACrC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,SAAO,gBAAgB,EAAC,QAAQ,KAAI,GAAG,oBAAoB,MAAM,WAAW;AAC9E;AAOA,SAAS,gBAAgB,MAAM,aAAa;AAC1C,SAAO,gBAAgB,CAAC,GAAG,sBAAsB,MAAM,WAAW;AACpE;AAOA,SAAS,QAAQ,MAAM,aAAa;AAClC,SAAO,gBAAgB,CAAC,GAAG,aAAa,MAAM,WAAW;AAC3D;AAOA,SAAS,QAAQ,MAAM,aAAa;AAClC,QAAM,OAAO,SAAS,IAAI;AAC1B,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,SAAO;AAAA,IACL,EAAC,QAAQ,KAAI;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAOA,SAAS,SAAS,MAAM,aAAa;AACnC,SAAO,gBAAgB,CAAC,GAAG,cAAc,MAAM,WAAW;AAC5D;AAOA,SAAS,cAAc,MAAM,aAAa;AACxC,QAAM,OAAO,KAAK,aAAa,MAAM;AACrC,QAAM,QAAQ,gBAAgB,CAAC,GAAG,mBAAmB,MAAM,WAAW;AACtE,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AACA,QAAM;AAAA;AAAA,IAAgC,YAAY,YAAY,SAAS,CAAC;AAAA;AACxE,SAAO,IAAI,IAAI;AACjB;AAOA,SAAS,uBAAuB,MAAM,aAAa;AACjD,SAAO,gBAAgB,CAAC,GAAG,6BAA6B,MAAM,WAAW;AAC3E;AAOA,SAAS,UAAU,MAAM,aAAa;AACpC,SAAO,gBAAgB,CAAC,GAAG,eAAe,MAAM,WAAW;AAC7D;AAOA,SAAS,0BAA0B,MAAM,aAAa;AACpD,SAAO,gBAAgB,CAAC,GAAG,gCAAgC,MAAM,WAAW;AAC9E;AAOA,SAAS,mBAAmB,MAAM,aAAa;AAC7C,SAAO,gBAAgB,CAAC,GAAG,yBAAyB,MAAM,WAAW;AACvE;AAOA,SAAS,oBAAoB,MAAM,aAAa;AAC9C,SAAO,gBAAgB,CAAC,GAAG,0BAA0B,MAAM,WAAW;AACxE;AAOA,SAAS,UAAU,MAAM,aAAa;AACpC,SAAO,WAAW,IAAI;AACxB;AAEA,IAAO,cAAQ;;;ACjTf,IAAMA,kBAAiB,CAAC,MAAM,iCAAiC;AAM/D,IAAM,qBAAqB,CAAC,MAAM,gCAAgC;AAOlE,IAAMC,WAAU,gBAAgBD,iBAAgB;AAAA,EAC9C,YAAY,yBAAyB,YAAY;AACnD,CAAC;AAQD,IAAM,mBAAN,cAA+B,YAAI;AAAA,EACjC,cAAc;AACZ,UAAM;AAMN,SAAK,aAAa,IAAI,YAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAM;AACjB,QAAI,UAAU,KAAK,aAAa,SAAS;AACzC,QAAI,SAAS;AACX,gBAAU,QAAQ,KAAK;AAAA,IACzB;AACA,QAAI,uBAAuB,KAAK,WAAW,aAAa,IAAI;AAC5D,QAAI,CAAC,sBAAsB;AACzB,aAAO;AAAA,IACT;AACA,yBAAqB,SAAS,IAAI;AAClC,2BAAuB;AAAA,MACrB;AAAA,MACAC;AAAA,MACA;AAAA,MACA,CAAC;AAAA,IACH;AACA,WAAO,uBAAuB,uBAAuB;AAAA,EACvD;AACF;AAOA,IAAM,mBAAmB,gBAAgBD,iBAAgB;AAAA,EACvD,SAAS,yBAAyB,SAAS;AAAA,EAC3C,iBAAiB,yBAAyB,iBAAiB;AAC7D,CAAC;AAOD,IAAM,gBAAgB;AAAA,EACpBA;AAAA,EACA;AAAA,IACE,SAAS,yBAAyB,SAAS;AAAA,IAC3C,UAAU,yBAAyB,UAAU;AAAA,IAC7C,qBAAqB,yBAAyB,qBAAqB;AAAA,IACnE,aAAa,yBAAyB,cAAc;AAAA,IACpD,eAAe,yBAAyB,eAAe;AAAA,EACzD;AAAA,EACA,gBAAgB,oBAAoB;AAAA,IAClC,SAAS,yBAAyB,UAAU;AAAA,IAC5C,YAAY,yBAAyB,UAAU;AAAA,IAC/C,oBAAoB,yBAAyB,eAAe;AAAA,IAC5D,eAAe,yBAAyB,sBAAsB;AAAA,IAC9D,cAAc,yBAAyB,UAAU;AAAA,EACnD,CAAC;AACH;AAOA,IAAM,gBAAgB;AAAA,EACpBA;AAAA,EACA;AAAA,IACE,aAAa,yBAAyB,aAAa;AAAA,EACrD;AAAA,EACA,gBAAgB,oBAAoB;AAAA,IAClC,SAAS,yBAAyB,UAAU;AAAA,IAC5C,cAAc,yBAAyB,UAAU;AAAA,EACnD,CAAC;AACH;AAOA,IAAM,oBAAoB,gBAAgBA,iBAAgB;AAAA,EACxD,iBAAiB,yBAAyB,UAAU;AAAA,EACpD,uBAAuB,yBAAyB,wBAAwB;AAC1E,CAAC;AAOD,IAAM,0BAA0B,gBAAgBA,iBAAgB;AAAA,EAC9D,oBAAoB,gBAAgB,oBAAoB;AAC1D,CAAC;AAOD,IAAM,qBAAqB,gBAAgBA,iBAAgB;AAAA,EACzD,cAAc,yBAAyB,UAAU;AAAA,EACjD,cAAc,yBAAyB,mBAAmB;AAAA,EAC1D,cAAc,yBAAyB,mBAAmB;AAAA,EAC1D,cAAc,yBAAyB,mBAAmB;AAAA,EAC1D,cAAc,yBAAyB,mBAAmB;AAC5D,CAAC;AAOD,IAAM,oBAAoB;AAAA,EACxBA;AAAA,EACA;AAAA,IACE,WAAW,yBAAyB,UAAU;AAAA,IAC9C,SAAS,yBAAyB,UAAU;AAAA,EAC9C;AAAA,EACA,gBAAgB,oBAAoB;AAAA,IAClC,cAAc,yBAAyB,UAAU;AAAA,EACnD,CAAC;AACH;AAOA,IAAM,qBAAqB,gBAAgB,oBAAoB;AAAA,EAC7D,eAAe,gBAAgB,eAAe;AAAA,EAC9C,eAAe,gBAAgB,eAAe;AAChD,CAAC;AAOD,IAAM,cAAc;AAAA,EAClBA;AAAA,EACA;AAAA,IACE,qBAAqB,yBAAyB,UAAU;AAAA,IACxD,cAAc,yBAAyB,cAAc;AAAA,EACvD;AAAA,EACA,gBAAgB,oBAAoB;AAAA,IAClC,gBAAgB,yBAAyB,UAAU;AAAA,IACnD,cAAc,yBAAyB,UAAU;AAAA,IACjD,eAAe,yBAAyB,eAAe;AAAA,EACzD,CAAC;AACH;AAOA,IAAM,aAAa;AAAA,EACjBA;AAAA,EACA;AAAA,IACE,iBAAiB,yBAAyB,eAAe;AAAA,IACzD,oBAAoB,yBAAyB,WAAW;AAAA,IACxD,aAAa,yBAAyB,mBAAmB;AAAA,IACzD,cAAc,yBAAyB,mBAAmB;AAAA,IAC1D,eAAe,yBAAyB,mBAAmB;AAAA,IAC3D,gBAAgB,yBAAyB,mBAAmB;AAAA,EAC9D;AAAA,EACA,gBAAgB,oBAAoB;AAAA,IAClC,cAAc,yBAAyB,UAAU;AAAA,EACnD,CAAC;AACH;AAOA,SAAS,aAAa,MAAM,aAAa;AACvC,SAAO,gBAAgB,CAAC,GAAG,kBAAkB,MAAM,WAAW;AAChE;AAOA,SAAS,UAAU,MAAM,aAAa;AACpC,SAAO,gBAAgB,CAAC,GAAG,eAAe,MAAM,WAAW;AAC7D;AAOA,SAAS,kBAAkB,MAAM,aAAa;AAC5C,SAAO,gBAAgB,CAAC,GAAG,aAAa,MAAM,WAAW;AAC3D;AAOA,SAAS,UAAU,MAAM,aAAa;AACpC,QAAM,QAAQ,gBAAgB,CAAC,GAAG,eAAe,MAAM,WAAW;AAClE,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AACA,QAAM,YAAY,KAAK,aAAa,WAAW,MAAM;AACrD,QAAM,WAAW,IAAI;AACrB,SAAO;AACT;AAOA,SAAS,sBAAsB,MAAM,aAAa;AAChD,SAAO,gBAAgB,CAAC,GAAG,mBAAmB,MAAM,WAAW;AACjE;AAOA,SAAS,eAAe,MAAM,aAAa;AACzC,SAAO,gBAAgB,CAAC,GAAG,mBAAmB,MAAM,WAAW;AACjE;AAOA,SAAS,gBAAgB,MAAM,aAAa;AAC1C,QAAM,SAAS,KAAK,aAAa,QAAQ;AACzC,QAAM,WAAW,KAAK,aAAa,UAAU;AAC7C,QAAM,eAAe,KAAK,aAAa,cAAc;AACrD,QAAM,WAAW,CAAC;AAClB,MAAI,QAAQ;AACV,aAAS,QAAQ,IAAI;AAAA,EACvB;AACA,MAAI,UAAU;AACZ,aAAS,UAAU,IAAI;AAAA,EACzB;AACA,MAAI,cAAc;AAChB,aAAS,cAAc,IAAI;AAAA,EAC7B;AACA,SAAO;AACT;AAOA,SAAS,gBAAgB,MAAM,aAAa;AAC1C,QAAM,cAAc;AAAA,IAClB,CAAC;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,YAAY,UAAU,GAAG;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,eAAe,WAAW;AACnC;AAOA,SAAS,uBAAuB,MAAM,aAAa;AACjD,QAAM,MAAM,KAAK,aAAa,KAAK;AACnC,QAAM,cAAc;AAAA,IAClB,CAAC;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,YAAY,UAAU,GAAG;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,EAAC,QAAQ,eAAe,WAAW,GAAG,IAAQ;AACvD;AAOA,SAAS,cAAc,MAAM,aAAa;AACxC,QAAM,SAAS,CAAC;AAChB,SAAO,QAAQ,IAAI,KAAK,aAAa,QAAQ;AAC7C,SAAO,MAAM,IAAI,SAAS,IAAI;AAC9B,SAAO;AACT;AAOA,SAAS,gBAAgB,MAAM,aAAa;AAC1C,QAAM,cAAc,WAAW,IAAI,EAAE,MAAM,KAAK;AAChD,MAAI,CAAC,eAAe,YAAY,UAAU,GAAG;AAC3C,WAAO;AAAA,EACT;AACA,QAAM,IAAI,CAAC,YAAY,CAAC;AACxB,QAAM,IAAI,CAAC,YAAY,CAAC;AACxB,MAAI,MAAM,CAAC,KAAK,MAAM,CAAC,GAAG;AACxB,WAAO;AAAA,EACT;AACA,SAAO,CAAC,GAAG,CAAC;AACd;AAOA,SAAS,eAAe,MAAM,aAAa;AACzC,SAAO,gBAAgB,CAAC,GAAG,YAAY,MAAM,WAAW;AAC1D;AAOA,SAAS,yBAAyB,MAAM,aAAa;AACnD,SAAO,gBAAgB,CAAC,GAAG,yBAAyB,MAAM,WAAW;AACvE;AAOA,SAAS,qBAAqB,MAAM,aAAa;AAC/C,SAAO,gBAAgB,CAAC,GAAG,oBAAoB,MAAM,WAAW;AAClE;AAEA,IAAO,2BAAQ;",
  "names": ["NAMESPACE_URIS", "PARSERS"]
}
